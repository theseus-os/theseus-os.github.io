<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://theseus-os.github.io/blog/" version="0.1.0">Theseus OS Blog</generator>
    <link href="https://theseus-os.github.io/blog/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://theseus-os.github.io/blog/" rel="alternate" type="text/html" />
    <id>https://theseus-os.github.io/blog/</id>
    <title>Theseus OS Blog</title>
    <subtitle>Status updates and info about Theseus OS development.</subtitle>
    <author>
        <name>Maintained by Kevin Boos and the Theseus OS Maintainers.</name>
        <uri>https://github.com/theseus-os/blog/</uri>
    </author>
    <updated>2022-04-08T18:58:04+00:00</updated>

    
    <entry>
        <title>2021: A Year in Review</title>
        <link rel="alternate" href="https://theseus-os.github.io/blog/2022/01/13/Theseus-Year-In-Review-2021.html" type="text/html" title="2021: A Year in Review" />
        <published>2022-01-13T00:00:00+00:00</published>
        <updated>2022-01-13T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/blog/2022/01/13/Theseus-Year-In-Review-2021.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/blog/2022/01/13/Theseus-Year-In-Review-2021.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#theseuss-first-full-year&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;theseuss-first-full-year&quot;&gt;&lt;/a&gt;Theseus&#x27;s First Full Year&lt;/h2&gt;
&lt;p&gt;Although 2021 not the first year of Theseus development, it &lt;em&gt;was&lt;/em&gt; the first whole year in which:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Theseus was fully open-sourced and publically known to the community.&lt;/li&gt;
&lt;li&gt;Theseus received interest from academic and industry collaborators.&lt;/li&gt;
&lt;li&gt;Theseus received funding for open-source development from industry (yay!).&lt;/li&gt;
&lt;li&gt;Our focus shifted from prototyping research concepts to feature completeness, stabilization, and legacy compatibility.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;The rest of this blog entry is a work in progress. Check back soon!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- ### Adding more features --&gt;
&lt;!-- ### Legacy compatibility --&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#thanks-to-2021s-contributors&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks-to-2021s-contributors&quot;&gt;&lt;/a&gt;Thanks to 2021&#x27;s Contributors!&lt;/h3&gt;
&lt;p&gt;Beyond our usual contributors, we had several newcomers from both Yale University and the open-source community at large who generously devoted their time to make some excellent improvements to Theseus.
Our sincere thanks to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Futurewei Technologies, especially &lt;a href&#x3D;&quot;https://www.linkedin.com/in/sid-askary-21a962&quot;&gt;Sid Askary&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.linkedin.com/in/yong-he-1334902&quot;&gt;Yong He&lt;/a&gt;, for generously offering technical advice and funding for Theseus development.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/apogeeoak&quot;&gt;@apogeeoak&lt;/a&gt;, who improved documentation quality and implemented GitHub workflows to autogenerate docs.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/vikrammullick&quot;&gt;Vikram Mullick&lt;/a&gt;, who began and nearly finished support for running WASM+WASI binaries atop Theseus.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jacob-earle&quot;&gt;Jacob Earle&lt;/a&gt;, who began support for logging output on ARM microcontrollers and a pseudo-real time scheduling algorithm for Theseus.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/joshtriplett&quot;&gt;Josh Triplett&lt;/a&gt;, who served as a valuable font of advice and sounding board for some of my wild Theseus ideas.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/phil-opp&quot;&gt;Philipp Oppermann&lt;/a&gt;, whose project &lt;a href&#x3D;&quot;https://os.phil-opp.com/&quot;&gt;Blog OS&lt;/a&gt; helped kickstart Theseus development a few years ago.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>October 2021 Update: All about WASM</title>
        <link rel="alternate" href="https://theseus-os.github.io/blog/2021/11/01/October-Update-WASM.html" type="text/html" title="October 2021 Update: All about WASM" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/blog/2021/11/01/October-Update-WASM.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/blog/2021/11/01/October-Update-WASM.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#bringing-the-wonderful-world-of-wasm-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;bringing-the-wonderful-world-of-wasm-to-theseus&quot;&gt;&lt;/a&gt;Bringing the Wonderful World of WASM to Theseus&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Theseus&#x27;s newest goal is to be a &lt;strong&gt;WASM-native&lt;/strong&gt; system, in which a fully-featured WASM runtime can execute in a bare metal environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://webassembly.org/&quot;&gt;WebAssembly&lt;/a&gt; (WASM) is a powerful new binary instruction format that offers a &amp;quot;sandboxed&amp;quot; execution environment based on a simple machine model.
WASM&#x27;s goal is to allow code from a variety of programming languages to be easily deployed on and performantly executed within a web browser-provided environment, effectively realizing the portability dream once envisioned by Java&#x27;s bytecode format.&lt;/p&gt;
&lt;p&gt;In addition, multiple extensions to the standard help to expand WASM&#x27;s functionality beyond just what is offered by most browsers.
The most notable is &lt;a href&#x3D;&quot;https://github.com/WebAssembly/WASI&quot;&gt;WASI&lt;/a&gt;, the WebAssembly System Interface, which extends WASM&#x27;s core functionality with common system-provided features like standard I/O, filesystems, clocks and timekeeping, and more.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#why-wasm-on-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-wasm-on-theseus&quot;&gt;&lt;/a&gt;Why WASM on Theseus?&lt;/h3&gt;
&lt;p&gt;WASM is the solution to one of the major downsides of safe-language OSes: all components must be written in a safe language in order to uphold the isolation and safety guarantees provided by said language compiler.
This can make it tedious or impossible to support legacy components and interfaces.&lt;/p&gt;
&lt;p&gt;With a WASM runtime, Theseus could safely load and run software modules written in any arbitrary unsafe language!
All you&#x27;d need to do is compile them into a WASM module, which is quite easy thanks to most major languages supporting WASM targets.
This will also make it significantly easier to run legacy components with complex dependency chains atop Theseus, as we can bundle them all up into self-contained WASM modules with little to no external dependencies.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#how-do-we-get-there&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-do-we-get-there&quot;&gt;&lt;/a&gt;How do we get there?&lt;/h3&gt;
&lt;p&gt;To bring WASM to Theseus, we have started two concurrent projects:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The simple approach: use the &lt;a href&#x3D;&quot;https://github.com/paritytech/wasmi&quot;&gt;&lt;code&gt;wasmi&lt;/code&gt; intepreter crate from parity-tech&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Relatively simple, as &lt;code&gt;wasmi&lt;/code&gt; is &lt;code&gt;no_std&lt;/code&gt;-compliant and requires only minimal interfacing with the host platform in order to use it&lt;/li&gt;
&lt;li&gt;We can implement WASI system calls as needed, which acts as the glue is the glue between the WASM environment and the rest of Theseus&#x27;s subsystems&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The complex approach: port the &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime&quot;&gt;&lt;code&gt;wasmtime&lt;/code&gt; WASM runtime project&lt;/a&gt; to Theseus
&lt;ul&gt;
&lt;li&gt;Massively complex with dozens of platform-specific logic and API calls&lt;/li&gt;
&lt;li&gt;Tons of legacy dependencies, e.g., libc- and POSIX-style memory management, signal handling, system calls, and usage of many Rust libstd features&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/vikrammullick&quot;&gt;Vikram Mullick&lt;/a&gt; has begun working on part 1 above as part of his senior capstone project at Yale.
&lt;a href&#x3D;&quot;https://github.com/kevinaboos&quot;&gt;Kevin Boos&lt;/a&gt; has begun working on part 2 above, and will also assist with part 1 as needed.&lt;/p&gt;
&lt;p&gt;Due to the complex nature of &lt;code&gt;wasmtime&lt;/code&gt; with its many legacy dependencies, this two-pronged split approach is quite beneficial, giving us the best of both worlds:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Theseus can &amp;quot;quickly&amp;quot; get up and running with basic WASM support, allowing us to:
&lt;ul&gt;
&lt;li&gt;Experiment with running legacy components as WASM modules&lt;/li&gt;
&lt;li&gt;Begin implementing support for WASI and other key WASM interfaces, e.g., WebGL&lt;/li&gt;
&lt;li&gt;Integrate Theseus&#x27;s existing runtime loading and linking infrastructure with WASM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can leverage the existing WASM and WASI infrastructure layers to more easily support &lt;code&gt;wasmtime&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;This will realize a ~10x performance improvement over the initial &lt;code&gt;wasmi&lt;/code&gt;, without wasting the initial &lt;code&gt;wasmi&lt;/code&gt;-based efforts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We look forward to announcing WASM support for Theseus and realizing its full potential as a WASM-native system.&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>August/September Update: A Proper Terminal Emulator</title>
        <link rel="alternate" href="https://theseus-os.github.io/blog/2021/10/04/August-September-Update.html" type="text/html" title="August/September Update: A Proper Terminal Emulator" />
        <published>2021-10-04T00:00:00+00:00</published>
        <updated>2021-10-04T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/blog/2021/10/04/August-September-Update.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/blog/2021/10/04/August-September-Update.html">&lt;p&gt;As mentioned in our &lt;a href&#x3D;&quot;./2021-08-02-June-July-2021-Update.md&quot;&gt;previous update&lt;/a&gt;, we&#x27;re working to support headless operation in Theseus such that it can run in an seL4 guest VM, which doesn&#x27;t support graphical displays.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#going-headless-with-a-proper-terminal-interface&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;going-headless-with-a-proper-terminal-interface&quot;&gt;&lt;/a&gt;Going Headless with a Proper Terminal Interface&lt;/h2&gt;
&lt;p&gt;We took a three-step approach towards realizing a proper headless interactive terminal:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Removing the requirement that a graphical display (e.g., VGA device) must exist for Theseus to successfully boot.
&lt;ul&gt;
&lt;li&gt;Now, if no display devices are not found, bootstrap and init can proceed, and headless operation is assumed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devising a new input dataflow and event manager, with the serial port as the focal data source and sink.
&lt;ul&gt;
&lt;li&gt;Monitors input sources for new connections asynchronously and spawns handlers for them upon receival.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create a new terminal emulator that:
&lt;ul&gt;
&lt;li&gt;Offers abstraction layers to support both graphical &lt;em&gt;and&lt;/em&gt; non-graphical terminals.&lt;/li&gt;
&lt;li&gt;Supports conventional escape and control codes, compliant with most ANSI, VT100, and xterm.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#yet-another-serial-port-driver-redesign&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;yet-another-serial-port-driver-redesign&quot;&gt;&lt;/a&gt;Yet Another Serial Port Driver Redesign&lt;/h3&gt;
&lt;p&gt;Our existing serial port driver was very simple -- it synchronously transmitted output bytes and simply dumped input bytes.
Thus, the receive interrupt handler was trivially simple and executed quickly.&lt;/p&gt;
&lt;p&gt;However, the added complexity of doing actual work (e.g., spawning a new console/terminal instance) in the receive interrupt handler caused it to become prohibitively expensive to run.
Executing long-running operations in an interrupt handler is unacceptable: &lt;em&gt;(i)&lt;/em&gt; it prevents that CPU from doing any other work, and &lt;em&gt;(ii)&lt;/em&gt; it harms system interactiveness by preventing other interrupts from being handled.&lt;/p&gt;
&lt;p&gt;To avoid this, we used Theseus&#x27;s &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/async_channel/index.html&quot;&gt;asynchronous channels&lt;/a&gt; to establish a communication channel between the serial port interrupt handler and a separate &lt;em&gt;listener&lt;/em&gt; task.
The listener task blocks until receiving a notification from any serial port, upon which it spawns a new console and terminal instance using that serial port and an input source and an output sink.&lt;/p&gt;
&lt;p&gt;This design has one drawback: it requires &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/3e805f1799964f5b63c48d7ad6a072f130256445/kernel/console/src/lib.rs#L32-L39&quot;&gt;proactively spawning a dedicated task just to listen for notifications from the serial port&lt;/a&gt;.
That led us to realize that it was time to introduce a better abstraction: deferred and/or linked interrupt handlers.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#deferred-interrupt-handlers&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;deferred-interrupt-handlers&quot;&gt;&lt;/a&gt;Deferred Interrupt Handlers&lt;/h4&gt;
&lt;p&gt;Theseus&#x27;s &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/deferred_interrupt_tasks/index.html&quot;&gt;Deferred Interrupt Handlers&lt;/a&gt; are an extension of the concept of &amp;quot;bottom half&amp;quot; and &amp;quot;top half&amp;quot; interrupt handlers&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Interrupt Handler&lt;/em&gt; (aka &amp;quot;top half&amp;quot;): the short, latency-sensitive function that runs synchronously, immediately when the interrupt request is serviced. It typically does two things:
&lt;ol&gt;
&lt;li&gt;Notifies the deferred task that work is ready to be done (optionally providing details about that work), and&lt;/li&gt;
&lt;li&gt;Acknowledges the interrupt such that the hardware knows it was handled.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Deferred task&lt;/em&gt; (aka &amp;quot;bottom half&amp;quot;): the more complex function that runs in a deferred manner to handle longer operations.
&lt;ul&gt;
&lt;li&gt;Runs asynchronously in a non-interrupt context and can thus perform more long-running operations without blocking the rest of that CPU&#x27;s workloads.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Theseus&#x27;s deferred interrupt handling implementation is conceptually similar to but differs from tasklets and workqueues in Linux.
The deferred task is uniquely tied to an interrupt handler in a 1-to-1 manner upon creation and are fully type-safe; there is a direct, strongly-typed channel of communication between them&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.
The deferred task can also optionally be configured to execute immediately after the interrupt handler in order to reduce I/O device latency, thanks to scheduler integration.&lt;/p&gt;
&lt;p&gt;Our favorite side benefit of this design is that itencourages adherence to the &lt;em&gt;separation of concerns&lt;/em&gt; principle, as the interrupt handling functionality must be conciously divided into an &amp;quot;urgent&amp;quot; synchronous part and a deferred asynchronous part.&lt;/p&gt;
&lt;p&gt;With this new interrupt handling architecture, we were able to adapt the serial driver to work efficiently without having unnecessary listener tasks wasting memory and CPU cycles.
The serial port is a simple case, as the interrupt handler only need to notify the deferred task that data has been received on the port and then acknowledge the interrupt; no other data exchange is needed.
The deferred task can then read all received data from the serial port in a non-urgent manner and do anything else necessary, such as spawning new console/terminal instances.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#splitting-the-serial-port-driver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;splitting-the-serial-port-driver&quot;&gt;&lt;/a&gt;Splitting the Serial Port Driver&lt;/h4&gt;
&lt;p&gt;Theseus&#x27;s design specifies a &lt;em&gt;tiny&lt;/em&gt; minimal kernel boot image, the &lt;code&gt;nano_core&lt;/code&gt; which must include only the bare minimum components to be able to bootstrap the OS and then dynamically load all other OS initialization components.
One of these components is the serial port driver, as it&#x27;s the only real usable choice for early boot/kernel logging in the absence of display, networking, or file support.&lt;/p&gt;
&lt;p&gt;With the above additions to the serial port driver, namely the usage of deferred interrupts and channels, the driver was becoming far too complex.
It had gone from having zero dependencies to having dozens.
That bloated the size of the &lt;code&gt;nano_core&lt;/code&gt;, thereby harming the dynamicness of Theseus.&lt;/p&gt;
&lt;p&gt;To solve this, we &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/d6b86b6c46004513735079bed47ae21fc5d4b29d&quot;&gt;split the serial port driver into two parts&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/serial_port_basic/index.html&quot;&gt;Basic driver&lt;/a&gt;: a standalone crate that exposes the &lt;code&gt;SerialPort&lt;/code&gt; type, which only offers functions to initialize, read from, and write to the device.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/serial_port/index.html&quot;&gt;Full driver&lt;/a&gt;: offers full I/O support with trait implementations, deferred interrupts, channel usage, task blocking, and more.
&lt;ul&gt;
&lt;li&gt;Wraps the basic driver&#x27;s &lt;code&gt;SerialPort&lt;/code&gt; type with additional functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This design enables two previously-conflicting goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The majority of system components can access the full functionality of the serial port and use it just like any other I/O device.&lt;/li&gt;
&lt;li&gt;The kernel boot image is kept tiny with minimal dependencies whilst still being able to output logs to the serial port.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#a-complete-terminal-emulator-rewrite&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-complete-terminal-emulator-rewrite&quot;&gt;&lt;/a&gt;A Complete Terminal Emulator Rewrite&lt;/h3&gt;
&lt;p&gt;Finally, we began the most complicated component of true interactive headless operation: a terminal emulator.
Theseus&#x27;s existing terminal is fairly ad-hoc and doesn&#x27;t conform to any real standards; it was implemented quickly as a summer intern project and offers just enough features to run commands and display their output.
The same is true for Theseus&#x27;s &lt;code&gt;stdio&lt;/code&gt;, which is a &amp;quot;quick-n-dirty&amp;quot; inflexible implementation that uses heap buffers instead of a real file abstraction.&lt;/p&gt;
&lt;p&gt;As anyone who has dealt with this knows, terminal emulators are &lt;em&gt;exceedingly&lt;/em&gt; and unexpectedly complex.
We experimented with multiple iterations of the design, primarily centered around how best to represent each displayable &amp;quot;unit&amp;quot; or &amp;quot;cell&amp;quot; on the terminal display:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, in which each element can contain either a single character or a string of characters (no matter how wide) as long as they have the same style.
&lt;ul&gt;
&lt;li&gt;Easy to output to a text backend.&lt;/li&gt;
&lt;li&gt;The most memory efficient.&lt;/li&gt;
&lt;li&gt;Calculating line wrapping and cursor navigation is overly complex because each unit may have a different columnar display width.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, but each element in the line can only contain a single &lt;em&gt;character&lt;/em&gt;.
&lt;ul&gt;
&lt;li&gt;Slightly less memory efficient, as it duplicates units that have the same style.&lt;/li&gt;
&lt;li&gt;Easier to calculate displayed rows and cursor movement than design 1, but still complex.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, but each element corresponds to a &lt;em&gt;single displayed column&lt;/em&gt; on screen.
&lt;ul&gt;
&lt;li&gt;Requires more memory and a little bit of extra effort to support wide characters, since they must be split across more than one element.&lt;/li&gt;
&lt;li&gt;Much, much easier to calculate cursor movements, line wrapping, and display commands.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a fixed number of elements per line, equivalent to the width of the screen row; blank units are inserted to fill each linas necessary.
&lt;ul&gt;
&lt;li&gt;Very wasteful of memory, especially for short lines (common in terminal output).&lt;/li&gt;
&lt;li&gt;Trivial to calculate displayed rows and cursor movement.&lt;/li&gt;
&lt;li&gt;Very hard to re-size/re-flow the terminal.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After multiple iterations, we settled on &lt;strong&gt;Design 3&lt;/strong&gt; above.
It selects the best set of tradeoffs in the spectrum of design points, and most importantly, simplifies the translation between on-screen coordinates and scrollback buffer coordinate.&lt;/p&gt;
&lt;p&gt;One interesting aspect of Theseus&#x27;s terminal emulator is how it&#x27;s split into multiple components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;frontend&lt;/em&gt;: a single entity responsible for handling incoming character and control/escape code bytes and determining what actions should be taken.
&lt;ul&gt;
&lt;li&gt;The frontend is also reusable as a terminal driver, &lt;code&gt;readline&lt;/code&gt; library, and line discipline layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;backend&lt;/em&gt; abstraction: a trait that represents the various display actions that a terminal might invoke.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;backend&lt;/em&gt; implentation(s): one of multiple entity types that handles display actions to &amp;quot;render&amp;quot; the terminal output in different formats:
&lt;ul&gt;
&lt;li&gt;Graphical pixel framebuffers&lt;/li&gt;
&lt;li&gt;Classic 80x25 VGA screen with 16-color basic text display&lt;/li&gt;
&lt;li&gt;A serial port connected to a host-side pseudo-terminal&lt;/li&gt;
&lt;li&gt;A network connection or file or any other sink&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, this is still a work in progress and is not yet used for Theseus&#x27;s main terminal display.
It takes quite a lot of effort to get all the details right, but we have an MVP that supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Insert/replace mode switching&lt;/li&gt;
&lt;li&gt;Automatic CR/LF behavior with wrapping&lt;/li&gt;
&lt;li&gt;Multiple different PTY backends, e.g., &lt;code&gt;screen&lt;/code&gt;, &lt;code&gt;picocom&lt;/code&gt;, &lt;code&gt;minicom&lt;/code&gt;, etc&lt;/li&gt;
&lt;li&gt;Most ANSI escape/control codes, including colors and text styles&lt;/li&gt;
&lt;li&gt;Cursor movement and scrolling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, there are several Rust terminal emulators that serve as valuable examples, e.g., &lt;a href&#x3D;&quot;https://github.com/alacritty&quot;&gt;Alacritty&lt;/a&gt;, but they&#x27;re standalone monolithic projects that rely on an underlying graphics stack like OpenGL and are thus inappropriate for in-kernel usage.
We were able to use the excellent &lt;a href&#x3D;&quot;https://crates.io/crates/vte&quot;&gt;&lt;code&gt;vte&lt;/code&gt;&lt;/a&gt; crate from the Alacritty project though, which saved a lot of time and effort in parsing ANSI/VT100 control codes.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Did you know that the &amp;quot;grid&amp;quot; of a terminal screen is indexed starting at &lt;code&gt;(1,1)&lt;/code&gt; rather than &lt;code&gt;(0,0)&lt;/code&gt; for the upper-leftmost character? &lt;sup&gt; Oh, how I wish I knew that earlier...&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#other-improvements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-improvements&quot;&gt;&lt;/a&gt;Other Improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Improved safety, complexity, and performance of &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/419&quot;&gt;interpreting a memory region as an executable function&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Previously called &lt;code&gt;MappedPages::as_func()&lt;/code&gt;, now moved into the crate management subsystem as a member function of the &lt;code&gt;LoadedSection&lt;/code&gt; type.&lt;/li&gt;
&lt;li&gt;The new &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/crate_metadata/struct.LoadedSection.html#method.as_func&quot;&gt;&lt;code&gt;LoadedSection::as_func()&lt;/code&gt; method&lt;/a&gt; already knows both the size of the function&#x27;s section and whether the underlying memory is executable, which omits multiple runtime checks.&lt;/li&gt;
&lt;li&gt;The function interface is much simpler, as the caller need not specify any size or offset values w.r.t. the memory region.&lt;/li&gt;
&lt;li&gt;Improves safety: offers a compile-time guarantee that an executable function instance can only be obtained from a &lt;code&gt;LoadedSection&lt;/code&gt; (with proper alignment and size) rather than any chunk of executable memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Re-designed parts of the &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/df721e35221d361f8ec8fd87364133f0be0f5cde&quot;&gt;&lt;code&gt;Task&lt;/code&gt; struct to reduce lock contention&lt;/a&gt;, eliminating it in most places.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;Mutable&amp;quot; fields (those that may change after &lt;code&gt;Task&lt;/code&gt; creation) are now moved into a &lt;code&gt;TaskInner&lt;/code&gt; struct (excluding atomic fields), which allows most fields to be accessed without acquiring the lock on that &lt;code&gt;Task&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Immutable fields are kept in the &amp;quot;outer&amp;quot; &lt;code&gt;Task&lt;/code&gt; struct.&lt;/li&gt;
&lt;li&gt;We ensure atomic types are properly aligned and sized such that native atomic instructions are actually used. We realized this by switching from &lt;code&gt;atomic::Atomic&lt;/code&gt; to &lt;code&gt;crossbeam_utils::atomic::AtomicCell&lt;/code&gt;, plus static assertions that all types wrapped in &lt;code&gt;AtomicCell&lt;/code&gt; are actually eligible for native atomic access.&lt;/li&gt;
&lt;li&gt;Move a Task&#x27;s &lt;code&gt;ExitValue&lt;/code&gt; out of its &lt;code&gt;RunState&lt;/code&gt; enum so that the &lt;code&gt;RunState&lt;/code&gt; enum can be accessed atomically and independently of an &lt;code&gt;ExitValue&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;runstate&lt;/code&gt; and &lt;code&gt;running_on_cpu&lt;/code&gt; fields of &lt;code&gt;Task&lt;/code&gt; are now atomically accessible in a lock-free manner, allowing us to block/unblock tasks in lock-free contexts, e.g., within an interrupt handler.&lt;/li&gt;
&lt;li&gt;As more &lt;code&gt;Task&lt;/code&gt; fields are now readable without locking, we can remove all now-unnecessary unsafe statements from the &lt;code&gt;scheduler&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Other terminology is often used, including &amp;quot;first-level&amp;quot; and &amp;quot;second-level&amp;quot; interrupt handlers, or &amp;quot;hard&amp;quot; and &amp;quot;soft&amp;quot; interrupt handlers. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;It is also possible to have a pool of deferred tasks, in which each task can be tied to multiple interrupt handlers. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>June/July Update: Headless Operation on seL4</title>
        <link rel="alternate" href="https://theseus-os.github.io/blog/2021/08/02/June-July-2021-Update.html" type="text/html" title="June/July Update: Headless Operation on seL4" />
        <published>2021-08-02T00:00:00+00:00</published>
        <updated>2021-08-02T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/blog/2021/08/02/June-July-2021-Update.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/blog/2021/08/02/June-July-2021-Update.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#one-very-busy-very-hot-summer&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;one-very-busy-very-hot-summer&quot;&gt;&lt;/a&gt;One Very Busy, Very Hot Summer&lt;/h2&gt;
&lt;p&gt;In June of this year, the Seattle area hit record high temperatures of over 110¬∞F (44¬∞C) for three days. Ouch!&lt;/p&gt;
&lt;p&gt;We began this hot summer with the goal of enabling Theseus to run atop seL4, using both its hypervisor and VMM functionality to present Theseus with a standard &amp;quot;bare metal&amp;quot; x86 environment.
Unfortunately, we quickly discovered that while &lt;a href&#x3D;&quot;https://docs.sel4.systems/Tutorials/camkes-vm-linux.html&quot;&gt;seL4 supports ARM and x86&lt;/a&gt;, it does not yet fully support x86_64 VMMs, which is the only architecture that Theseus currently runs on.
The implementation of an x86_64 VMM was supposedly &lt;a href&#x3D;&quot;https://dornerworks.com/blog/64-bit-x86-architecture-on-sel4/&quot;&gt;completed by Dornerworks&lt;/a&gt;, but we were unable to get it to successfully run any x86_64 guest OS (but x86 VMs did work properly).
We have decided to postpone this particular effort until &lt;a href&#x3D;&quot;https://github.com/seL4/seL4/pull/324&quot;&gt;this PR&lt;/a&gt; that officially adds support for x86_64 VMMs on seL4 is accepted.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#headless-operation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;headless-operation&quot;&gt;&lt;/a&gt;Headless operation&lt;/h2&gt;
&lt;p&gt;In the meantime, we started working towards Theseus-level support for &lt;em&gt;headless&lt;/em&gt; operation over a serial port interface.
The serial port is the only form of direct interactive access to guest VMs on seL4 (excluding network access), so it is a necessary component to debug and use Theseus therein.
It&#x27;s also useful for communicating with serial devices on other more limited platforms, e.g., our &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/361&quot;&gt;WIP port of Theseus to ARM Cortex-M4 microcontrollers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Previously, Theseus had two problems in this area:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All input to the shell/terminal was assumed to come from a real keyboard and mouse.&lt;/li&gt;
&lt;li&gt;The serial port was only used for basic logging output (not treated as a regular I/O device).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To achieve headless operation, we had to set two corresponding goals:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Abstract the terminal and input handling to work with any I/O source, not just a physical keyboard.&lt;/li&gt;
&lt;li&gt;Enable full, bidirectional, arbitrary I/O across serial ports.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-io-abstractions--stateless-vs-stateful&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-io-abstractions--stateless-vs-stateful&quot;&gt;&lt;/a&gt;New I/O Abstractions:  Stateless vs. Stateful&lt;/h3&gt;
&lt;p&gt;As the first step towards these goals, we created &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/051e52782658a3e0f11c486d8656e71da1f7ba07/kernel/io/src/lib.rs&quot;&gt;several new I/O traits&lt;/a&gt; to represent different categories of I/O.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockReader.html&quot;&gt;&lt;code&gt;BlockReader&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockWriter.html&quot;&gt;&lt;code&gt;BlockWriter&lt;/code&gt;&lt;/a&gt; traits represent I/O streams which can be read from or written to at the granularity of a single block (as the smallest transferable chunk).&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockIo.html&quot;&gt;&lt;code&gt;BlockIo&lt;/code&gt;&lt;/a&gt; is a &amp;quot;parent&amp;quot; trait that specifies the size in bytes of each block
in a block-based I/O stream.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.KnownLength.html&quot;&gt;&lt;code&gt;KnownLength&lt;/code&gt;&lt;/a&gt;: a separate trait that represents an I/O stream with a known length, such as a disk drive.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.ByteReader.html&quot;&gt;&lt;code&gt;ByteReader&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.ByteWriter.html&quot;&gt;&lt;code&gt;ByteWriter&lt;/code&gt;&lt;/a&gt;: traits that represent I/O streams which can be read from or written to at the granularity of an individual byte.&lt;/li&gt;
&lt;li&gt;We also provide wrapper types that allow byte-wise access atop block-based I/O streams: &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteReaderWrapper.html&quot;&gt;&lt;code&gt;ByteReaderWrapper&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteWriterWrapper.html&quot;&gt;&lt;code&gt;ByteWriterWrapper&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteReaderWriterWrapper.html&quot;&gt;&lt;code&gt;ByteReaderWriterWrapper&lt;/code&gt;&lt;/a&gt;.
&lt;ul&gt;
&lt;li&gt;The &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/fn.blocks_from_bytes.html&quot;&gt;&lt;code&gt;blocks_from_bytes()&lt;/code&gt;&lt;/a&gt; function is useful for calculating the set of block-based I/O transfers that are needed to satisfy an arbitrary byte-wise transfer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notably, these traits all offer &lt;em&gt;&lt;strong&gt;stateless&lt;/strong&gt;&lt;/em&gt; access to byte streams only, an important behavioral characteristic that helps simplify state management in Theseus.
This means that they don&#x27;t keep track of an internal offset within the stream.&lt;/p&gt;
&lt;p&gt;For example, the &lt;code&gt;ByteReader&lt;/code&gt; trait exposes only one function that requires the caller to specify at which offset the stream read should start.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn read_at(&amp;amp;mut self, buffer: &amp;amp;mut [u8], offset: usize) -&amp;gt; Result&amp;lt;...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These traits and types also &lt;em&gt;stack&lt;/em&gt; on top of each other, e.g., you can use a &lt;code&gt;ByteReader&lt;/code&gt; to realize byte-wise access to an underlying block-based I/O device that implements &lt;code&gt;BlockReader&lt;/code&gt;.
We make this easier with trait &lt;em&gt;delegation&lt;/em&gt;, in which wrapper types &amp;quot;forward&amp;quot; the trait implementation through:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;References (&lt;code&gt;&amp;amp;dyn ByteReader&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Mutable References (&lt;code&gt;&amp;amp;mut dyn ByteReader&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Locks (&lt;code&gt;Mutex&amp;lt;ByteReader&amp;gt;&lt;/code&gt;) using the &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.LockableIo.html&quot;&gt;&lt;code&gt;LockableIo&lt;/code&gt;&lt;/a&gt; type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also offer &lt;em&gt;&lt;strong&gt;stateful&lt;/strong&gt;&lt;/em&gt; I/O types, which wrap stateless I/O streams (the above traits) to track the current offset into the I/O stream while reading or writing it.
This is similar to classic POSIX I/O interfaces, but are strongly-typed and allow for limited permissions: &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ReaderWriter.html&quot;&gt;&lt;code&gt;ReaderWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.Reader.html&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.Writer.html&quot;&gt;&lt;code&gt;Writer&lt;/code&gt;&lt;/a&gt; structs.&lt;/p&gt;
&lt;p&gt;Finally, all of the above types and traits implement the &lt;code&gt;no_std&lt;/code&gt; version of &lt;code&gt;std::io::Read&lt;/code&gt;/&lt;code&gt;Write&lt;/code&gt; traits, which can come from crates like &lt;a href&#x3D;&quot;https://crates.io/crates/core_io&quot;&gt;&lt;code&gt;core_io&lt;/code&gt;&lt;/a&gt; or &lt;a href&#x3D;&quot;https://crates.io/crates/bare-io&quot;&gt;&lt;code&gt;bare_io&lt;/code&gt;&lt;/a&gt;.
This widely expands their compatibility to work with pretty much any other I/O-related code in the Rust ecosystem.&lt;/p&gt;
&lt;p&gt;For example, we used these new I/O abstractions to integrate the &lt;a href&#x3D;&quot;https://github.com/rafalh/rust-fatfs&quot;&gt;&lt;code&gt;fatfs&lt;/code&gt; Rust crate&lt;/a&gt; with Theseus, which allows Theseus to read and write the contents of a FAT filesystem on disk.
More work is required to provide a more generic file abstraction that can represent arbitrary files across any filesystem type, as Theseus&#x27;s current representation of files is quite ad-hoc and limited to in-memory filesystems.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#redesigned-serial-port-driver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;redesigned-serial-port-driver&quot;&gt;&lt;/a&gt;Redesigned Serial Port Driver&lt;/h3&gt;
&lt;p&gt;With redesigned I/O traits, we can proceed to our second goal: improving the serial port driver.&lt;/p&gt;
&lt;p&gt;On x86 machines, there are up to 4 serial ports, but commonly only one or two are available: &lt;code&gt;COM1&lt;/code&gt; and &lt;code&gt;COM2&lt;/code&gt;.
The OS can interact with them using different I/O ports, e.g., writing bytes to &lt;code&gt;0x3F8&lt;/code&gt; and the subsequent 7 port addresses will allow you to communicate with the &lt;code&gt;COM1&lt;/code&gt; serial port.
Here are three great resources for learning more about serial port behavior and how to write a proper driver: &lt;a href&#x3D;&quot;https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming&quot;&gt;one&lt;/a&gt;, &lt;a href&#x3D;&quot;https://tldp.org/HOWTO/Modem-HOWTO-4.html&quot;&gt;two&lt;/a&gt;, &lt;a href&#x3D;&quot;https://wiki.osdev.org/Serial_Ports&quot;&gt;three&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The changes we needed to make are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implement and activate interrupt handlers for all serial ports, such that the hardware triggers an interrupt when input bytes are received on the port.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SerialPort&lt;/code&gt; instances are no longer exclusively owned by the logger, as they must be accessible from within the serial port interrupt handler and other kernel/application crates.&lt;/li&gt;
&lt;li&gt;Implement the necessary read and write I/O traits for the &lt;code&gt;SerialPort&lt;/code&gt; type, so we can use them in all I/O stream contexts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these changes in place, Theseus is now able to read from and write to serial ports freely, as if it were any other I/O stream like a file or disk.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#other-improvements-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-improvements-to-theseus&quot;&gt;&lt;/a&gt;Other Improvements to Theseus&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Updated Theseus&#x27;s Rust compiler to version 1.54, which entailed &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/b7d62ee0197347b651e2cf1387f83c9c4a598633&quot;&gt;many changes&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Refactoring all inline assembly to Rust&#x27;s new &lt;code&gt;asm!()&lt;/code&gt; syntax.&lt;/li&gt;
&lt;li&gt;Complying with the restrictions on naked functions: Rust ABI is no longer allowed, and only one assembly block is permitted per naked function.&lt;/li&gt;
&lt;li&gt;Use the new &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.compare_exchange_weak&quot;&gt;&lt;code&gt;compare_exchange_weak()&lt;/code&gt;&lt;/a&gt; family of functions, which is more efficient on some architectures (ARM) because it is allowed to spuriously fail.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Refactored code for memory-related types to unify their APIs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/417&quot;&gt;&lt;code&gt;VirtualAddress&lt;/code&gt; and &lt;code&gt;PhysicalAddress&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/6854306a8f2c16f3caf1332120856a0fff8de25f&quot;&gt;&lt;code&gt;Page&lt;/code&gt; and &lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/b09ad9bc73683397a0b16b9b53f9214bdf87c04d&quot;&gt;&lt;code&gt;PageRange&lt;/code&gt; and &lt;code&gt;FrameRange&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Book documentation: thanks to &lt;a href&#x3D;&quot;https://github.com/apogeeoak&quot;&gt;@apogeeoak&lt;/a&gt;, the Theseus Book now has clearer structure, automatic spell check, and is built and published online via GitHub Actions CI workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mellanox 100GiB NIC: &lt;a href&#x3D;&quot;https://github.com/Ramla-I&quot;&gt;Ramla Ijaz&lt;/a&gt; added basic support for &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/404&quot;&gt;initializing and configuring this high-performance NIC&lt;/a&gt;. Packet transmission is an ongoing work in progress.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Added support for parsing the ACPI &lt;code&gt;DMAR&lt;/code&gt; table, which specifies details about the system&#x27;s IOMMU.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is part of our quest to protect Theseus&#x27;s single address space execution environment from errant or malicious I/O devices that attempt to access arbitrary system memory without permission, the one final frontier in the &amp;quot;chain of safety&amp;quot; that cannot be checking by the compiler.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#contributions-to-other-open-source-projects&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributions-to-other-open-source-projects&quot;&gt;&lt;/a&gt;Contributions to other Open-Source Projects&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We added &lt;a href&#x3D;&quot;https://github.com/rafalh/rust-fatfs/pull/44&quot;&gt;compile-time configuration of logging flexibility&lt;/a&gt; to the &lt;code&gt;rust-fatfs&lt;/code&gt; crate.&lt;/li&gt;
&lt;li&gt;We ported the MPMC Queue crate to &lt;a href&#x3D;&quot;https://github.com/brayniac/mpmc/pull/8&quot;&gt;support &lt;code&gt;no_std&lt;/code&gt; environments&lt;/a&gt; on the latest version of Rust.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Now that we have flexible, generic I/O abstractions available in Theseus, the next step for achieving full headless operation is to enable a terminal/CLI to handle I/O to and from arbitrary sources, such as a serial port.&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>Hello (World!) from Theseus</title>
        <link rel="alternate" href="https://theseus-os.github.io/blog/2021/06/28/Hello-Theseus.html" type="text/html" title="Hello (World!) from Theseus" />
        <published>2021-06-28T00:00:00+00:00</published>
        <updated>2021-06-28T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/blog/2021/06/28/Hello-Theseus.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/blog/2021/06/28/Hello-Theseus.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#theseuss-first-blog-post&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;theseuss-first-blog-post&quot;&gt;&lt;/a&gt;Theseus&#x27;s First Blog Post&lt;/h2&gt;
&lt;p&gt;Hello, World!&lt;/p&gt;
&lt;p&gt;This is the introductory post for the Theseus OS Blog, which will be used to provide more details about the changes and developmental progress of &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus&quot;&gt;Theseus OS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this blog, we hope to achieve the following goals:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provide an easier, more transparent way to follow changes to Theseus OS than having to pore over GitHub commits&lt;/li&gt;
&lt;li&gt;Announce major changes, feature additions, and releases&lt;/li&gt;
&lt;li&gt;Share interesting tidbits related to low-level and embedded Rust development&lt;/li&gt;
&lt;li&gt;Inspire folks in the open-source community to get involved and contribute&lt;/li&gt;
&lt;li&gt;Collect thoughts, ideas, and feedback from the Rust and OS community more directly&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-path-from-research-to-usability&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-path-from-research-to-usability&quot;&gt;&lt;/a&gt;The Path from Research to Usability&lt;/h2&gt;
&lt;p&gt;Since development began at Rice University a few years ago, our focus has been solely on pursuing designs with strong research merit rather than achieveing usability or feature-completeness.
As such, the current state of Theseus is a strange (im)balance between:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;üòä An existing set of highly-advanced system features:
&lt;ul&gt;
&lt;li&gt;Fully-safe memory management for arbitrary memory regions&lt;/li&gt;
&lt;li&gt;Compiler-assisted resource and state management&lt;/li&gt;
&lt;li&gt;Dynamic loading and linking of system components at runtime&lt;/li&gt;
&lt;li&gt;Full cuustom unwinding from high-level applications to low-level kernel entities&lt;/li&gt;
&lt;li&gt;Robust fault tolerance with a tiny core dependency set&lt;/li&gt;
&lt;li&gt;Live evolution of components at any layer/level of the system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;üôÅ More &amp;quot;basic&amp;quot; features that are missing:
&lt;ul&gt;
&lt;li&gt;No true support for filesystems&lt;/li&gt;
&lt;li&gt;Interactive shell is very minimal&lt;/li&gt;
&lt;li&gt;Poor graphics support with slow compositing&lt;/li&gt;
&lt;li&gt;Lacking device support beyond mouse, keyboard, and networking&lt;/li&gt;
&lt;li&gt;Cannot run standard applications that use libc/libstd&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;That all changes today!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We&#x27;ll now focus on proving that Theseus can be useful in real-world environments (beyond just research applications) by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyzing, auditing, and shoring up its existing functionality&lt;/li&gt;
&lt;li&gt;Fleshing out its interfaces and missing subsystems&lt;/li&gt;
&lt;li&gt;Improving stability, genericness, and usability of primary subsystems&lt;/li&gt;
&lt;li&gt;Working on legacy compatibility, including libc, Rust&#x27;s libstd, and running WASM binaries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That being said, researchers at Yale University will continue to use Theseus as a foundation for novel OS research, and their contributions may be featured here as well, when appropriate.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#funding-from-futurewei&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;funding-from-futurewei&quot;&gt;&lt;/a&gt;Funding from Futurewei&lt;/h2&gt;
&lt;p&gt;Since being published in the &lt;a href&#x3D;&quot;https://www.usenix.org/conference/osdi20/presentation/boos&quot;&gt;SOSP 2020 conference&lt;/a&gt;, Theseus has garnered a lot of interest from both fellow academic institutions as well as industry researchers.
Among the interested parties was &lt;a href&#x3D;&quot;https://futurewei.com/&quot;&gt;Futurewei Technologies&lt;/a&gt;, who reached out to our research lab at Yale University (previously at Rice University) to inquire about the future of Theseus and to determine whether it could prove useful for various important domains, such as automotive computing.&lt;/p&gt;
&lt;p&gt;Futurewei graciously offered to fund me (Kevin Boos), the creator of Theseus, to work on Theseus in a full-time capacity.
Futurewei has made a formal committment that all intellectual property and artifacts produced from work on Theseus will continue to be made open-source and remain so indefinitely, and that we will retain full control of the direction of the project.
In addition, Futurewei has committed to funding a variety of other significant projects, teams, and individuals in the Rust community, from Rust core, compiler, and language teams themselves to folks like us working on Rust-centric projects.
Together, we&#x27;re building a strong Rust ecosystem for the next generation of safe, efficient computing.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#looking-forward&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;looking-forward&quot;&gt;&lt;/a&gt;Looking forward&lt;/h2&gt;
&lt;p&gt;I am both honored and excited to be able to continue developing Theseus, which was born out of my PhD dissertation research.
In the coming months, we plan to work on some fascinating topics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Running Theseus atop seL4 and other secure hypervisors&lt;/li&gt;
&lt;li&gt;Executing WASM + WASI binaries on Theseus&lt;/li&gt;
&lt;li&gt;Implementing support for filesystems, async/await, libc, and libstd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks for reading, and be on the lookout for more content soon. Feel free to contact us via email or on GitHub with comments or questions.&lt;/p&gt;
&lt;p&gt;To learn more, use the links up top to explore the Theseus Book and source code.&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
</feed>
