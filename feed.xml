<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://theseus-os.github.io/" version="0.1.0">Theseus OS Blog</generator>
    <link href="https://theseus-os.github.io/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://theseus-os.github.io/" rel="alternate" type="text/html" />
    <id>https://theseus-os.github.io/</id>
    <title>Theseus OS Blog</title>
    <subtitle>Status updates and info about Theseus OS development.</subtitle>
    <author>
        <name>Maintained by Kevin Boos and the Theseus OS Maintainers.</name>
        <uri>https://github.com/theseus-os/</uri>
    </author>
    <updated>2022-07-12T06:23:53+00:00</updated>

    
    <entry>
        <title>Porting Wasmtime to no_std atop Theseus</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/06/21/wasmtime-complete-no_std-port.html" type="text/html" title="Porting Wasmtime to no_std atop Theseus" />
        <published>2022-06-21T00:00:00+00:00</published>
        <updated>2022-06-21T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/06/21/wasmtime-complete-no_std-port.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/06/21/wasmtime-complete-no_std-port.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#bringing-wasmtime-to-no_std&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;bringing-wasmtime-to-no_std&quot;&gt;&lt;/a&gt;Bringing Wasmtime to &lt;code&gt;no_std&lt;/code&gt;*&lt;/h2&gt;
&lt;p&gt;üéâüéâ Wasmtime now builds and runs on Theseus! üéâüéâ&lt;/p&gt;
&lt;p&gt;This is the first port of Wasmtime to a &lt;code&gt;no_std&lt;/code&gt;* environment, to the best of our knowledge, despite it being a &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/issues/75&quot;&gt;very&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/pull/2024&quot;&gt;hot&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/pull/554&quot;&gt;topic&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/issues/3495&quot;&gt;of&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/issues/3451&quot;&gt;conversation&lt;/a&gt;.
We completed the initial minimal version of Wasmtime and &lt;a href&#x3D;&quot;https://github.com/kevinaboos/Theseus/commit/39a647581fdb7f259559400b6222613e3f914916&quot;&gt;successfully ran it on Theseus on May 17th, 2022&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This milestone marks the culmination of a very long journey, as evidenced by our previous several posts on this topic
and the fact that our initial port started with a version of Wasmtime from mid-October 2021. Yeesh!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;../../../2021/11/01/October-Update-WASM.html&quot;&gt;November 2021: Introducing the goal of running WASM on Theseus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;../../../2021/12/31/November-December-Update-WASM.html#progress-on-porting-wasmtime-to-theseus&quot;&gt;December 2021: Porting the low-level &amp;quot;simple&amp;quot; Wasmtime crates and dependencies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;../../../2022/02/03/wasmtime-progress-update.html&quot;&gt;February 2022: Porting the largest crate, &lt;code&gt;wasmtime-runtime&lt;/code&gt;, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;../../../2022/04/12/wasmtime-progress-update-2.html&quot;&gt;April 2022: Porting &lt;code&gt;wasmtime-runtime&lt;/code&gt;, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;This post: Porting the top-level &lt;code&gt;wasmtime&lt;/code&gt; crate and tying everything together&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this post, we aim to&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provide a high-level overview of Wasmtime and its multi-crate architecture,&lt;/li&gt;
&lt;li&gt;Enumerate the changes needed to build Wasmtime on &lt;code&gt;no_std&lt;/code&gt;*, and&lt;/li&gt;
&lt;li&gt;Itemize the dependencies/functionality that Wasmtime requires from the underlying platform.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;While we don&#x27;t intend this to be a step-by-step porting tutorial, we do hope it makes it easier to port and run Wasmtime on other platforms in the future.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Why is there an asterisk&lt;/strong&gt; by &lt;code&gt;no_std&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Theseus doesn&#x27;t yet support the &lt;code&gt;std&lt;/code&gt; library, so this is a legitimate &lt;code&gt;no_std&lt;/code&gt; port.
However, one cannot simply take this port and run it within any other &lt;code&gt;no_std&lt;/code&gt; environment,
because Wasmtime still relies on lots of functionality from the underlying platform.&lt;/p&gt;
&lt;p&gt;We did have to add some &lt;code&gt;std&lt;/code&gt;-like components to Theseus in order to satisfy Wasmtime&#x27;s needs, as shown below.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;quot;C&#x27;mon, just skip to the &lt;s&gt;recipe&lt;/s&gt; code already!&amp;quot;&lt;/p&gt;
&lt;p&gt;No problem, &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/compare/35cdd53989b5eaa01691aac915d60cf609776ab6..c05b37c41b363008b9ff84b3493ea6d4f067cf88&quot;&gt;here is the full changeset to Wasmtime&lt;/a&gt;.
Note that this doesn&#x27;t include the many changes and extensions we made to Theseus to support this; those are described in the rest of the article.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#1-summary-of-wasmtimes-key-parts&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;1-summary-of-wasmtimes-key-parts&quot;&gt;&lt;/a&gt;1. Summary of Wasmtime&#x27;s key parts&lt;/h2&gt;
&lt;p&gt;As described in &lt;a href&#x3D;&quot;https://docs.wasmtime.dev/contributing-architecture.html&quot;&gt;Wasmtime&#x27;s documentation&lt;/a&gt;, the project is architected as one top-level user-facing crate called &lt;code&gt;wasmtime&lt;/code&gt; that re-exports and connects together key functionality from several internal crates.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wasmtime-cli&lt;/code&gt;: a CLI app that offers simple interactive access to standard Wasmtime features&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime&lt;/code&gt;: exposes a safe, embeddable API for interacting with WASM modules, e.g., compiling, instantiating, and invoking them&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-jit&lt;/code&gt;: facilitates JIT compilation and execution of WASM modules using a compiler&#x27;s code generator (currently cranelift)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-runtime&lt;/code&gt;: implements the majority of the runtime logic for executing WASM binaries atop of a give host platform&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-environ&lt;/code&gt;: standalone abstract definitions of core WASM concepts and environment types, enabling integration with the cranelift backend&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-types&lt;/code&gt;: definitions for core WASM types and execution concepts&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmparser&lt;/code&gt;&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: an external (non-Wasmtime) tool for parsing WASM binaries&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- * &#x60;cranelift-entity&#x60;: core data structures used by the Cranelift code generator   --&gt;
&lt;p&gt;The diagram below depicts the above major components of Wasmtime&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and their dependencies, with a focus on those that &lt;em&gt;did not already support &lt;code&gt;no_std&lt;/code&gt;&lt;/em&gt; when our work began or required other forms of modification.
This intentionally excludes ubiquitous dependencies like error handling, heap allocation, and logging to keep the graph legible (...ish).
Note that the project also contains many other crates that realize optional features, such as module caching, fibers, etc, but these (and &lt;code&gt;wasmtime-cli&lt;/code&gt;) aren&#x27;t necessary for an initial port.&lt;/p&gt;
&lt;br&gt;
&lt;a href&#x3D;&quot;/images/2022-posts/wasmtime_diagram.svg&quot; alt&#x3D;&quot;Wasmtime architecture diagram with dependencies&quot; target&#x3D;&quot;_blank&quot;&gt;
  &lt;img align&#x3D;&quot;center&quot; src&#x3D;&quot;/images/2022-posts/wasmtime_diagram.svg&quot;/&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;div align&#x3D;&quot;center&quot;&gt;&lt;em&gt;(click diagram to open it in a full-size window)&lt;/em&gt;&lt;/div&gt;
&lt;br&gt;
&lt;a href&#x3D;&quot;/images/2022-posts/wasmtime_diagram_legend.svg&quot; alt&#x3D;&quot;Wasmtime architecture diagram legend&quot; target&#x3D;&quot;_blank&quot;&gt;
  &lt;img align&#x3D;&quot;center&quot; src&#x3D;&quot;/images/2022-posts/wasmtime_diagram_legend.svg&quot; width&#x3D;&quot;700&quot;/&gt;
&lt;/a&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#2-changes-made-to-wasmtime-components&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;2-changes-made-to-wasmtime-components&quot;&gt;&lt;/a&gt;2. Changes made to Wasmtime components&lt;/h2&gt;
&lt;p&gt;We took a bottom-up approach to iteratively port lower-level dependencies until they compiled on &lt;code&gt;no_std&lt;/code&gt; on Theseus, and then moved on to the next highest layer in the dependency stack.
The lowest-level crates, &lt;code&gt;wasmparser&lt;/code&gt;, &lt;code&gt;wasmtime-types&lt;/code&gt;, and &lt;code&gt;wasmtime-environ&lt;/code&gt; were relatively simple to port to &lt;code&gt;no_std&lt;/code&gt;, requiring only trivial changes &lt;a href&#x3D;&quot;#trivial-yet-tedious-changes-for-nostd-compatibility&quot;&gt;described in the section below&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By far, the most complex crate to port was &lt;code&gt;wasmtime-runtime&lt;/code&gt;, which has not only myriad dependencies that each need porting, but also plenty of platform-specific code that is necessarily unsafe and quite intricate.
We have already described our efforts to port &lt;code&gt;wasmtime-runtime&lt;/code&gt; to Theseus in &lt;a href&#x3D;&quot;../../../2022/02/03/wasmtime-progress-update.html&quot;&gt;two previous posts starting here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Moving up, porting &lt;code&gt;wasmtime-jit&lt;/code&gt; and then &lt;code&gt;wasmtime&lt;/code&gt; was fairly straightforward once &lt;code&gt;wasmtime-runtime&lt;/code&gt; was done, as they share many dependencies.
There were a few issues that needed fixing, as described below, but nothing strenuous.&lt;/p&gt;
&lt;p&gt;Finally, the real fun begins once all Wasmtime crates are able to be compiled for your platform!
You then attempt to run it for the first time only to discover that nothing works and you don&#x27;t know why.&lt;/p&gt;
&lt;p&gt;Welcome to integration hell! üòà&lt;/p&gt;
&lt;p&gt;... Ok, time to come clean; it turns out that this wasn&#x27;t so bad. We only had a few days of debugging struggles that centered around differences in how &lt;code&gt;bincode&lt;/code&gt; performs (de)serialization across different versions and how &lt;code&gt;region&lt;/code&gt; handles memory management on Unix vs. Theseus. Both are explained in the following sections.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#logic-and-structural-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;logic-and-structural-changes&quot;&gt;&lt;/a&gt;Logic and structural changes&lt;/h3&gt;
&lt;p&gt;As Wasmtime is cross-platform, it contains several platform-specific modules that we must implement for Theseus.
These typically look something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;if #[cfg(unix)] {
    mod systemv;
    pub use self::systemv::*;
} else if #[cfg(target_os &#x3D; &amp;quot;theseus&amp;quot;)] {
    mod theseus;
    pub use self::theseus::*;  
} else ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/blob/7879420c3c75a8514c0137928d998ef29f04b22d/crates/jit/src/unwind/theseus.rs&quot;&gt;Here&#x27;s an example of one such module&lt;/a&gt; in &lt;code&gt;wasmtime-jit&lt;/code&gt; that handles registering unwind info for new code regions that were JIT-compiled from WASM modules.&lt;/p&gt;
&lt;p&gt;Beyond these modules, we have encountered only a few places in which platform-agnostic code must be modified to support Theseus. Two such examples are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The aforementioned registration of unwind info:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;UnwindRegistration::new(
    text.as_ptr(),
    #[cfg(target_os &#x3D; &amp;quot;theseus&amp;quot;)]
    text.len(), // Theseus needs the text section&#x27;s length
    unwind_info.as_ptr(),
    unwind_info.len(),
)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Here, Theseus&#x27;s unwinder benefits from knowing both the starting &lt;em&gt;and&lt;/em&gt; ending bounds of the &lt;code&gt;.text&lt;/code&gt; section(s) that a given piece of unwind info covers; it helps accelerate the search for the unwind info that corresponds to a given stack frame&#x27;s caller virtual address.&lt;/li&gt;
&lt;li&gt;This stems from Theseus&#x27;s structure of many small crate object files all being loaded and linked at runtime, which results in many separate &lt;code&gt;.eh_frame&lt;/code&gt; sections that each contain unwind info for different &lt;code&gt;.text&lt;/code&gt; section address ranges.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The representation of memory-mapped region in &lt;code&gt;wasmtime-runtime&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub struct Mmap {
    ptr: usize,
    len: usize,
    file: Option&amp;lt;File&amp;gt;,
    #[cfg(target_os &#x3D; &amp;quot;theseus&amp;quot;)]
    theseus_mp: theseus_memory::MappedPages,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/blob/c05b37c41b363008b9ff84b3493ea6d4f067cf88/crates/runtime/src/mmap.rs#L172-L196&quot;&gt;Theseus-specific version of &lt;code&gt;Mmap::accessible_reserved()&lt;/code&gt;&lt;/a&gt; and other related functions were also necessary to accommodate the changed &lt;code&gt;Mmap&lt;/code&gt; struct.&lt;/li&gt;
&lt;li&gt;This design choice avoids unsafe or leaky code that would be required to get around the &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/memory/struct.MappedPages.html&quot;&gt;ownership-based type invariants guaranteed by &lt;code&gt;MappedPages&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Naturally, we made many other changes, but those were generally much smaller in scope and described in following separate sections.
The inquisitive reader can search &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/compare/35cdd53989b5eaa01691aac915d60cf609776ab6..c05b37c41b363008b9ff84b3493ea6d4f067cf88&quot;&gt;the full list of changes&lt;/a&gt; for &#x60;target_os &#x3D; &amp;quot;theseus to see other platform-specific modifications.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#minor-yet-tedious-changes-for-no_std-compatibility&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;minor-yet-tedious-changes-for-no_std-compatibility&quot;&gt;&lt;/a&gt;Minor yet &lt;strong&gt;tedious&lt;/strong&gt; changes for &lt;code&gt;no_std&lt;/code&gt; compatibility&lt;/h3&gt;
&lt;p&gt;Many other changes are trivial and thus glossed over in this post, such as changing import statements from &lt;code&gt;std::xyz&lt;/code&gt; to &lt;code&gt;core::xyz&lt;/code&gt; or &lt;code&gt;alloc::xyz&lt;/code&gt; and modifying or patching dependency chains to disable &lt;code&gt;default-features&lt;/code&gt;.
However, I don&#x27;t want to understate the pure tedium of such changes because they require a lot of effort for no actual difference in functionality.
Many of the code diffs look like the collage of boring tedium below:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-patch&quot;&gt;- use std::borrow::Borrow;
- use std::marker::PhantomData;
- use std::mem;
+ use core::borrow::Borrow;
+ use core::marker::PhantomData;
+ use core::mem;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-patch&quot;&gt;[dependencies]
- anyhow &#x3D; &amp;quot;1.0&amp;quot;
+ anyhow &#x3D; { version &#x3D; &amp;quot;1.0&amp;quot;, default-features &#x3D; false }
  cranelift-entity &#x3D; { path &#x3D; &amp;quot;../../cranelift/entity&amp;quot;, version &#x3D; &amp;quot;0.77.0&amp;quot; }
- wasmtime-types &#x3D; { path &#x3D; &amp;quot;../types&amp;quot;, version &#x3D; &amp;quot;0.30.0&amp;quot; }
+ wasmtime-types &#x3D; { path &#x3D; &amp;quot;../types&amp;quot;, default-features &#x3D; false, version &#x3D; &amp;quot;0.30.0&amp;quot; }
- wasmparser &#x3D; &amp;quot;0.81&amp;quot;
+ wasmparser &#x3D; { version &#x3D; &amp;quot;0.81&amp;quot;, default-features &#x3D; false }
  indexmap &#x3D; { version &#x3D; &amp;quot;1.0.2&amp;quot;, features &#x3D; [&amp;quot;serde-1&amp;quot;] }
- thiserror &#x3D; &amp;quot;1.0.4&amp;quot;
+ thiserror &#x3D; { version &#x3D; &amp;quot;1.0.4&amp;quot;, optional &#x3D; true }
- serde &#x3D; { version &#x3D; &amp;quot;1.0.94&amp;quot;, features &#x3D; [&amp;quot;derive&amp;quot;] }
+ serde &#x3D; { version &#x3D; &amp;quot;1.0.94&amp;quot;, default-features &#x3D; false, features &#x3D; [&amp;quot;derive&amp;quot;] }
  object &#x3D; { version &#x3D; &amp;quot;0.27&amp;quot;, default-features &#x3D; false, features &#x3D; [&#x27;read_core&#x27;, &#x27;write_core&#x27;, &#x27;elf&#x27;] }
+ hashbrown &#x3D; { version &#x3D; &amp;quot;0.11.2&amp;quot;, features &#x3D; [&amp;quot;ahash&amp;quot;], default-features &#x3D; false }
  ...

+ [patch.crates-io]
+ wasmparser &#x3D; { path &#x3D; &amp;quot;./path/to/ported/wasmparser/crate&amp;quot; }
+ object &#x3D; { path &#x3D; &amp;quot;./path/to/ported/object/crate&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... and the procedure to patch dependencies that have been ported to &lt;code&gt;no_std&lt;/code&gt; is even more tedious, shown below:
&lt;img src&#x3D;&quot;/images/2022-posts/porting_deps_to_no_std.svg&quot; alt&#x3D;&quot;porting_dependencies_to_no_std&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It would be a &lt;em&gt;&lt;strong&gt;fantastic&lt;/strong&gt;&lt;/em&gt; quality-of-life improvement if &lt;code&gt;std&lt;/code&gt;&#x27;s re-exports of items from &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; could be transparently converted to their &lt;code&gt;no_std&lt;/code&gt; equivalents, but that&#x27;s a topic for another day.
In fact I&#x27;ve already suggested this in a presentation to select Rust team members entitled &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/book/misc/papers_presentations.html#selected-presentations-and-slide-decks&quot;&gt;&amp;quot;How Theseus uses Rust, plus Rust challenges&amp;quot;, slides 47-51&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here are a few specific examples of changes that were conceptually minor yet tricky or tedious:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error handling, particularly usage of &lt;code&gt;anyhow&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;This boils down to error type mapping: &lt;code&gt;.map_err(anyhow::Error::msg)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Substituting &lt;code&gt;no_std&lt;/code&gt; versions of specific crates
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::io&lt;/code&gt; ‚Üí &lt;code&gt;core2::io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thiserror&lt;/code&gt; ‚Üí &lt;code&gt;thiserror_core2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;bincode&lt;/code&gt; for (de)serialization
&lt;ul&gt;
&lt;li&gt;In accordance with &lt;a href&#x3D;&quot;https://github.com/bincode-org/bincode/blob/trunk/docs/migration_guide.md&quot;&gt;&lt;code&gt;bincode&lt;/code&gt;&#x27;s migration guide&lt;/a&gt;, we migrated to version 2.0 that supports &lt;code&gt;no_std&lt;/code&gt;, typically like so:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-diff&quot;&gt;- bincode::deserialize(...)
+ bincode::serde::decode_from_slice(..., bincode::config::legacy())
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Side note: be sure to use the same versions of all types when you serialize and deserialize things... otherwise you&#x27;ll get those lovely mysterious errors and spend a whole two days trying to figure out which struct field is causing the problem. üôÑ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#3-full-list-of-functionality-needed-to-support-wasmtime&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;3-full-list-of-functionality-needed-to-support-wasmtime&quot;&gt;&lt;/a&gt;3. Full list of functionality needed to support Wasmtime&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Heap allocation for &lt;code&gt;alloc&lt;/code&gt; types
&lt;ul&gt;
&lt;li&gt;Sorry, you ain&#x27;t gonna run Wasmtime without a heap!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic memory management: allocating memory regions, creating memory mappings, etc.
&lt;ul&gt;
&lt;li&gt;Unix-like OSes leverage crates like &lt;code&gt;libc&lt;/code&gt;, &lt;code&gt;region&lt;/code&gt;, &lt;code&gt;rsix&lt;/code&gt; for this&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stack unwinding for proper panic handling and ensuring drop handlers run
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wasmtime-runtime&lt;/code&gt; requires both &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/panic/fn.catch_unwind.html&quot;&gt;&lt;code&gt;catch_unwind()&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/panic/fn.resume_unwind.html&quot;&gt;&lt;code&gt;resume_unwind()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Also need to support registration of external unwind info that comes from WASM modules compiled into native code, plus an unwinder that can utilize this info&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backtrace&lt;/code&gt; for capturing a stack trace
&lt;ul&gt;
&lt;li&gt;Plus optional symbolication of addresses, i.e., &lt;code&gt;addr2line&lt;/code&gt; functionality or similar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Signal handling for trapping between WASM and native execution contexts
&lt;ul&gt;
&lt;li&gt;On Theseus, this means registering custom handlers for CPU exceptions (see &lt;a href&#x3D;&quot;../../../2022/04/12/wasmtime-progress-update-2.html#the-last-sjedis-dependency-signal-handling&quot;&gt;prior post&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Editing object files
&lt;ul&gt;
&lt;li&gt;We contributed a PR to &lt;code&gt;object&lt;/code&gt; that allowed reading &lt;em&gt;and&lt;/em&gt; writing of object files in a &lt;code&gt;no_std&lt;/code&gt; environment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bincode&lt;/code&gt; + &lt;code&gt;serde&lt;/code&gt; for (de)serialization
&lt;ul&gt;
&lt;li&gt;Just had to upgrade to newer major version that already supported &lt;code&gt;no_std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Required some minor changes to how &lt;code&gt;wasmtime&lt;/code&gt; uses bincode, in accordance with &lt;a href&#x3D;&quot;https://github.com/bincode-org/bincode/blob/trunk/docs/migration_guide.md&quot;&gt;&lt;code&gt;bincode&lt;/code&gt;&#x27;s migration guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic support for accessing filesystem paths and reading files
&lt;ul&gt;
&lt;li&gt;Only needed when reading a AOT pre-compiled WASM module from a file for purposes of deserialization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multitasking
&lt;ul&gt;
&lt;li&gt;Full preemption is essentially required, as cooperative multitasking would require a significant rework of Wasmtime&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread-Local Storage (TLS), see &lt;a href&#x3D;&quot;../../../2022/02/03/wasmtime-progress-update.html#supporting-thread-local-storage-on-theseus&quot;&gt;prior post&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;TLS via the &lt;code&gt;thread_local!()&lt;/code&gt; macro is used to statefully handle traps and support stack unwinding during execution of native WASM module code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stack access
&lt;ul&gt;
&lt;li&gt;Typically via the &lt;code&gt;psm&lt;/code&gt; crate, for portable stack manipulation&lt;/li&gt;
&lt;li&gt;Only used to obtain the current value of the stack pointer register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O traits
&lt;ul&gt;
&lt;li&gt;Mostly just the basic ones from &lt;code&gt;std::io&lt;/code&gt;, which are usable in &lt;code&gt;core&lt;/code&gt; through a variety of &lt;code&gt;no_std&lt;/code&gt; crates like &lt;code&gt;core2&lt;/code&gt; (previously &lt;code&gt;bare_io&lt;/code&gt;), &lt;code&gt;core_io&lt;/code&gt;, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic error handling via &lt;code&gt;anyhow&lt;/code&gt; and &lt;code&gt;thiserror&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;anyhow&lt;/code&gt; already supports &lt;code&gt;no_std&lt;/code&gt;, but has a different API due to its reliance on &lt;code&gt;std::error::Error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thiserror&lt;/code&gt; cannot support &lt;code&gt;no_std&lt;/code&gt; yet, but there are &lt;code&gt;no_std&lt;/code&gt;-compatible drop-in alternatives like &lt;code&gt;thiserror_core2&lt;/code&gt; which derive &lt;code&gt;core2::error::Error&lt;/code&gt; instead&lt;/li&gt;
&lt;li&gt;Once the &lt;code&gt;std::error::Error&lt;/code&gt; trait is moved into &lt;code&gt;core&lt;/code&gt;, all of these pain points will be permanently healed!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A source of randomness
&lt;ul&gt;
&lt;li&gt;Easiest option is to use OS-provided RNG via &lt;code&gt;rand&lt;/code&gt;&#x27;s interface, or its &lt;code&gt;no_std&lt;/code&gt; &lt;code&gt;SmallRng&lt;/code&gt; feature&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic I/O for printing output to a screen, console, or log&lt;/li&gt;
&lt;li&gt;Mutual exclusion
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;spin&lt;/code&gt; crate provides an easy yet inefficient &lt;code&gt;no_std&lt;/code&gt; spinlock, but we do prefer to use Theseus&#x27;s own &lt;code&gt;Mutex&lt;/code&gt; that blocks the current task by putting it to sleep&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crc32fast&lt;/code&gt;, a dependency of the &lt;code&gt;object&lt;/code&gt; crate
&lt;ul&gt;
&lt;li&gt;We contributed a PR to make this compile properly for custom targets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;more_asserts&lt;/code&gt; for easy assertions
&lt;ul&gt;
&lt;li&gt;We contributed a trivial PR to make this &lt;code&gt;no_std&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#concluding-remarks--next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;concluding-remarks--next-steps&quot;&gt;&lt;/a&gt;Concluding remarks + next steps&lt;/h2&gt;
&lt;p&gt;Phew, that was a long ride ‚Äî but it&#x27;s only the beginning of the journey to bring Wasmtime to Theseus.
We still have several optional features to port and implement, starting with full support for live JIT compilation of WASM modules.
We then plan to integrate Theseus&#x27;s &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/0e61ea815cbf2dc4857b8e484a5f39587e6bc25a/kernel/wasi_interpreter/src/wasi_syscalls.rs&quot;&gt;existing WASI implementation&lt;/a&gt; with our port of Wasmtime such that we can more easily run legacy programs in a WASM environment.&lt;/p&gt;
&lt;p&gt;This is a major addition to a &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/book/design/idea.html&quot;&gt;safe-language OS&lt;/a&gt; like Theseus, which runs everything in a single address space and single privilege level, foregoing hardware protection in favor of reliance on language-provided safety to realize isolation between both applications and system components.
Importantly, this will enable Theseus to safely execute unsafe code or legacy components written in unsafe languages, using WASM as a &amp;quot;sandbox&amp;quot; to prevent unsafe code from circumventing the type-based restrictions  ensured and obeyed by the rest of the OS&#x27;s safe Rust environment.&lt;/p&gt;
&lt;p&gt;Further down the line, we would like to propose design changes to Wasmtime such that it makes greater usage of traits to abstract away its platform-specific dependencies as much as possible.
This would make it easier to port Wasmtime to new platforms, and ideally reduce the amount of mandatory unsafe code.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#small-demo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;small-demo&quot;&gt;&lt;/a&gt;Small demo&lt;/h3&gt;
&lt;p&gt;Given the following very simple WASM module &lt;code&gt;hello.wat&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-wasm&quot;&gt;(module
    (import &amp;quot;host&amp;quot; &amp;quot;hello&amp;quot; (func $host_hello (param i32)))
    (func (export &amp;quot;hello&amp;quot;)
        i32.const 3
        call $host_hello)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can precompile it using the &lt;code&gt;wasmtime-cli&lt;/code&gt; on Linux or another machine:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-bash&quot;&gt;wasmtime --compile --target x86_64-theseus hello.was --output hello.cwasm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run that precompiled &lt;code&gt;hello.cwasm&lt;/code&gt; binary using the following host code on Theseus:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use wasmtime::{Caller, Engine, Func, Instance, Module, Store};

/// Taken from the docs example code in &#x60;wasmtime/crates/wasmtime/src/lib.rs&#x60;.
fn hello(cwasm_file_contents: &amp;amp;[u8]) -&amp;gt; Result&amp;lt;...&amp;gt; {
    let engine &#x3D; Engine::default();
    // Deserialize the AOT pre-compiled WASM binary
    let module &#x3D; unsafe {
        Module::deserialize(&amp;amp;engine, cwasm_file_contents)? 
    };
    let mut store &#x3D; Store::new(&amp;amp;engine, 4);
    let host_hello &#x3D; Func::wrap(&amp;amp;mut store, |caller: Caller&amp;lt;&#x27;_, u32&amp;gt;, param: i32| {
        println!(&amp;quot;Got {} from WebAssembly&amp;quot;, param);
        println!(&amp;quot;my host state is: {}&amp;quot;, caller.data());
    });
    let instance &#x3D; Instance::new(&amp;amp;mut store, &amp;amp;module, &amp;amp;[host_hello.into()])?;
    let hello &#x3D; instance.get_typed_func::&amp;lt;(), (), _&amp;gt;(&amp;amp;mut store, &amp;quot;hello&amp;quot;)?;
    // Invoke the WASM &#x60;hello&#x60; function
    hello.call(&amp;amp;mut store, ()).map_err(anyhow::Error::msg)?;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If all goes according to plan, you&#x27;ll see the expected output below:&lt;/p&gt;
&lt;img style&#x3D;&quot;margin:4px&quot; align&#x3D;&quot;left&quot; src&#x3D;&quot;/images/2022-posts/test_wasmtime_screenshot.png&quot; alt&#x3D;&quot;wasmtime on Theseus screenshot&quot; width&#x3D;&quot;500&quot;/&gt;
&lt;br clear&#x3D;&quot;all&quot;&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;For simplicity, we depict &lt;code&gt;wasmparser&lt;/code&gt; as part of the set of Wasmtime crates, even though it is actually part of the separate &lt;code&gt;wasm-tools&lt;/code&gt; project. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>Theseus is Hiring!</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/04/29/Theseus-Is-Hiring.html" type="text/html" title="Theseus is Hiring!" />
        <published>2022-04-29T00:00:00+00:00</published>
        <updated>2022-04-29T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/04/29/Theseus-Is-Hiring.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/04/29/Theseus-Is-Hiring.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#theseus-is-looking-for-systems-programmers&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;theseus-is-looking-for-systems-programmers&quot;&gt;&lt;/a&gt;Theseus is looking for systems programmers!&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The hiring window has closed. Check back again later this year, we may be hiring again!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Theseus is proud to be a member of a diverse ecosystem of open-source Rust projects sponsored by Futurewei Technologies.
Thanks to the generosity of Futurewei&#x27;s Rust initiative, Theseus is able to hire developers for the first time!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;To apply, send your resume or C.V. to &lt;a href&#x3D;&quot;mailto:theseus.systems@gmail.com&quot;&gt;theseus.systems@gmail.com&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Check out the below sections for more info.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2022-posts/theseus_plus_futurewei.svg&quot; alt&#x3D;&quot;Theseus plus Futurewei&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#job-title-operating-systems-developer&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;job-title-operating-systems-developer&quot;&gt;&lt;/a&gt;Job Title: Operating Systems Developer&lt;/h3&gt;
&lt;p&gt;As an OS developer, you will independently lead a major development project within Theseus OS.&lt;/p&gt;
&lt;p&gt;To lend some context, Theseus OS is a novel operating system written from scratch entirely in Rust,
with the objective of realizing next-generation safety and efficiency guarantees for workloads in a variety of execution environments.
Theseus&#x27;s goals span the gamut from supporting cutting-edge exploratory research topics to more practical concerns of achieving legacy compatibility and usability.&lt;/p&gt;
&lt;p&gt;Lately, our focus is on deep support for WebAssembly (WASM) interfaces and runtimes, as well as porting Theseus to additional architectures (e.g., ARM).
As such, your development project (&lt;a href&#x3D;&quot;#project-ideas&quot;&gt;more ideas below&lt;/a&gt;) will likely be related to one of those areas.&lt;/p&gt;
&lt;p&gt;Other job responsibilities include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collaborating with the general public in an open-source environment&lt;/li&gt;
&lt;li&gt;Addressing issues and solving bugs/problems expediently&lt;/li&gt;
&lt;li&gt;Writing easily readable code and documenting it well&lt;/li&gt;
&lt;li&gt;Meeting with other Theseus OS developers, Rust developers, and Futurewei team members&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#location-and-more&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;location-and-more&quot;&gt;&lt;/a&gt;Location and more&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Fully remote&lt;/li&gt;
&lt;li&gt;Flexible work hours
&lt;ul&gt;
&lt;li&gt;Ideally 2+ hours of daily overlap with the US Pacific time zone&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Work-life balance is highly valued and respected&lt;/li&gt;
&lt;li&gt;Required equipment: any standard PC capable of running Linux/Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compensation-and-term&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compensation-and-term&quot;&gt;&lt;/a&gt;Compensation and Term&lt;/h3&gt;
&lt;p&gt;$35-$65 USD per hour (approx. $5,500-$10,000 USD monthly), commensurate with experience and performance.&lt;/p&gt;
&lt;p&gt;The initial employment term is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3-4 months if full-time (~40 hours per week)&lt;/li&gt;
&lt;li&gt;6-9 months if part-time (~20 hours per week)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Terms can be extended if the candidate performs well.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#eligibility&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;eligibility&quot;&gt;&lt;/a&gt;Eligibility&lt;/h3&gt;
&lt;p&gt;Theseus is a U.S.-based organization but does &lt;em&gt;not&lt;/em&gt; require citizenship, permanent residency, or work visa/authorization.&lt;/p&gt;
&lt;p&gt;Anyone from any country is welcome to apply, including but not limited to students, professionals, open-source developers, hobbyists, and more.
If in the U.S., you will be hired as a standard 1099 independent contractor, as with typical freelance work.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#desired-skills&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;desired-skills&quot;&gt;&lt;/a&gt;Desired Skills&lt;/h3&gt;
&lt;p&gt;The ideal candidate would have experience with at least one of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Systems programming languages
&lt;ul&gt;
&lt;li&gt;Rust preferred&lt;/li&gt;
&lt;li&gt;C, C++, or Assembly appreciated&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Operating Systems concepts
&lt;ul&gt;
&lt;li&gt;Multithreading and concurrency&lt;/li&gt;
&lt;li&gt;Memory management, virtual memory&lt;/li&gt;
&lt;li&gt;Architectural knowledge, e.g., ARM/x86&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic compiler or programming language concepts
&lt;ul&gt;
&lt;li&gt;Type safety, memory safety&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WebAssembly, sandboxing, software isolation&lt;/li&gt;
&lt;li&gt;Source code versioning via &lt;code&gt;git&lt;/code&gt; and the general GitHub workflow&lt;/li&gt;
&lt;li&gt;Working independently in a self-driven context&lt;/li&gt;
&lt;li&gt;Clear communication and technical writing skills (for documentation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&#x27;re not an expert in these areas, don&#x27;t worry! You&#x27;ll pick up any necessary skills while working with us. As academics at heart, we love teaching these concepts, and it&#x27;s always exciting to watch new OS concepts click.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#what-youll-learn&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-youll-learn&quot;&gt;&lt;/a&gt;What You&#x27;ll Learn&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Deep knowledge of how operating systems work under the hood&lt;/li&gt;
&lt;li&gt;Expertise in the Rust programming language&lt;/li&gt;
&lt;li&gt;How to write &lt;strong&gt;&lt;em&gt;safe&lt;/em&gt;&lt;/strong&gt;, easy-to-read, and robust code&lt;/li&gt;
&lt;li&gt;Experience with navigating/understanding large projects&lt;/li&gt;
&lt;li&gt;Skills for producing good documentation&lt;/li&gt;
&lt;li&gt;Best practices for contributing to public open-source projects&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#project-ideas&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;project-ideas&quot;&gt;&lt;/a&gt;Project Ideas&lt;/h3&gt;
&lt;p&gt;Projects are fairly open-ended and flexible; the topic is ultimately up to you, but should ideally relate to one of Theseus&#x27;s current development goals. We do encourage you to work on something that interests you personally.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you&#x27;ve ever caught yourself thinking &lt;em&gt;‚ÄúI&#x27;ve always wanted to know how XYZ works in an OS‚Äù&lt;/em&gt; then this is where you&#x27;ll shine (and get paid to follow your curiosity!).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Your project(s) will expand or improve upon the existing functionality of Theseus or add new features entirely. We have an extensive list of exciting project ideas that you can tackle or use as inspiration for an idea of your own:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extending support for running WebAssembly (WASM) on Theseus
&lt;ul&gt;
&lt;li&gt;Supporting more WASM interfaces, e.g., WASI extensions&lt;/li&gt;
&lt;li&gt;Improving WASM performance (e.g., with Wasmtime) atop Theseus&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Creating a generic universal driver abstraction for cross-OS driver reuse
&lt;ul&gt;
&lt;li&gt;Ask us about &lt;code&gt;WASI-dd&lt;/code&gt;: a future WASM-based interface for reusing drivers on any WASM-compliant OS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Deeper graphics support and a better graphics stack
&lt;ul&gt;
&lt;li&gt;Supporting WASM+WebGL workloads&lt;/li&gt;
&lt;li&gt;Creating a new more featureful window manager or compositor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Legacy compatibility: improving Theseus&#x27;s implementation of Rust&#x27;s &lt;code&gt;std&lt;/code&gt; library and/or &lt;code&gt;libc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Porting Theseus to another architecture, e.g., ARM &lt;code&gt;aarch64&lt;/code&gt;, RISC-V&lt;/li&gt;
&lt;li&gt;Driver development for additional devices and peripherals
&lt;ul&gt;
&lt;li&gt;Storage devices, GPUs, USB devices, audio chips, etc.&lt;/li&gt;
&lt;li&gt;Proper power management, ACPI shutdown, device/CPU suspend &amp;amp; resume&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Language-level: deeper integration and support for Rust&#x27;s async/await syntax&lt;/li&gt;
&lt;li&gt;See &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/wiki&quot;&gt;more project ideas here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#about-us-our-vision-and-culture&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;about-us-our-vision-and-culture&quot;&gt;&lt;/a&gt;About Us: our Vision and Culture&lt;/h3&gt;
&lt;p&gt;We strongly believe that Theseus OS is well-positioned to be the next great system for supporting complex dynamic workloads on both low-end and high-end embedded systems, datacenter servers, and any other single-operator computing environment &lt;strong&gt;where safety and efficient performance are key&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Theseus began as a research-oriented OS that focused on investigating the benefits of a unique OS structure and novel methods of state/resource management.&lt;/li&gt;
&lt;li&gt;Theseus has received positive feedback from experts in academia, appearing in top-tier conferences like the Symposium on Operating Systems and Principles (SOSP) in 2020.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are in the process of transitioning Theseus from a research prototype to a more usable fully-fledged operating system that will support arbitrary workloads, both existing popular applications and libraries as well as up-and-coming interfaces, e.g., WASM and its interface extensions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, we still retain that academic culture and feel of fearlessly exploring wild and wacky ideas without concern for commercial usability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As with most open-source projects, the work environment is casual and chill. While we do expect you to make progress, we are also all too familiar with the challenges inherent in OS development and are very understanding of unforeseen delays or complications. We&#x27;ll be there to guide you to overcome any difficulties/setbacks along the way.&lt;/p&gt;
&lt;p&gt;You&#x27;ll work directly with Kevin Boos, the creator of Theseus OS and founder of Theseus Systems. Kevin is the full-time lead developer and will work personally with you to specify your project, implement your design, and foster knowledge of the fundamentals of Rust, Theseus, and OS functionality.&lt;/p&gt;
&lt;p&gt;You&#x27;ll also interact with a variety of other contributors, such as technical managers and experts from Futurewei or systems professors and PhD students from Yale University and other academic institutions.&lt;/p&gt;
&lt;p&gt;Theseus OS is a fully open-source project that welcomes contributions from anyone. Thus, you may interact with the Rust or OS community at large, both of which are often recognized as the most welcoming of all online developer communities. Rustaceans are super friendly!&lt;/p&gt;
&lt;p&gt;We recognize your time is valuable: meetings are kept to a minimum! That being said, Kevin and others are always happy to meet with you and help you out at any time of day. Project guidance can be as hands-on or hands-off as you like, according to your preferred work style.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align&#x3D;&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align&#x3D;&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align&#x3D;&quot;center&quot;&gt;&lt;img src&#x3D;&quot;/images/2022-posts/kevin-boos.png&quot; alt&#x3D;&quot;Photo of Kevin Boos&quot; title&#x3D;&quot;Kevin Boos&quot; /&gt;&lt;/td&gt;
&lt;td align&#x3D;&quot;center&quot;&gt;&lt;img src&#x3D;&quot;/images/2022-posts/puma.png&quot; alt&#x3D;&quot;Photo of Puma&quot; title&#x3D;&quot;Puma the Pup&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align&#x3D;&quot;center&quot;&gt;&lt;div align&#x3D;&quot;center&quot;&gt; &lt;strong&gt;Kevin Boos&lt;/strong&gt; &lt;br&gt; Founder &amp;amp; Creator of Theseus &lt;br&gt; PhD, Rice University &lt;/div&gt;&lt;/td&gt;
&lt;td align&#x3D;&quot;center&quot;&gt;&lt;div align&#x3D;&quot;center&quot;&gt; &lt;strong&gt;Puma&lt;/strong&gt; &lt;br&gt; Chief Morale Officer &lt;br&gt; PhD in Ball Fetching, sneaky Zoom ninja &lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Thanks, and we look forward to meeting you!&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>More progress porting Wasmtime to Theseus</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/04/12/wasmtime-progress-update-2.html" type="text/html" title="More progress porting Wasmtime to Theseus" />
        <published>2022-04-12T00:00:00+00:00</published>
        <updated>2022-04-12T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/04/12/wasmtime-progress-update-2.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/04/12/wasmtime-progress-update-2.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#the-quest-port-continues&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-quest-port-continues&quot;&gt;&lt;/a&gt;The &lt;s&gt;quest&lt;/s&gt; port continues&lt;/h2&gt;
&lt;p&gt;This post covers the highlights of our ongoing work to port Wasmtime to Theseus; see the previous post(s) for more information.
Interested folks can &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/tree/theseus&quot;&gt;follow along with the ported Wasmtime code here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;üì¢ Good news: &lt;code&gt;wasmtime-runtime&lt;/code&gt; now builds on Theseus! üì¢&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#completed-initial-port-of-wasmtime-runtime&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;completed-initial-port-of-wasmtime-runtime&quot;&gt;&lt;/a&gt;Completed initial port of &lt;code&gt;wasmtime-runtime&lt;/code&gt;!&lt;/h3&gt;
&lt;p&gt;Last time we left off having finished several key features to support the needs of the &lt;code&gt;wasmtime-runtime&lt;/code&gt; crate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Thread-Local Storage (TLS)&lt;/li&gt;
&lt;li&gt;Creation and management of Unix-like memory-mapped areas via the &lt;code&gt;region&lt;/code&gt; and &lt;code&gt;libc&lt;/code&gt; crates
&lt;ul&gt;
&lt;li&gt;Plus additions to &lt;code&gt;tlibc&lt;/code&gt;, the Theseus-specific implementation of basic libc functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reading/writing of object files via the &lt;code&gt;object&lt;/code&gt; crate&lt;/li&gt;
&lt;li&gt;Improvements to Theseus&#x27;s &lt;code&gt;page_allocator&lt;/code&gt; and &lt;code&gt;theseus_cargo&lt;/code&gt; build tool to handle more complexity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The full list of required, target-agnostic dependencies is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[package]
name &#x3D; &amp;quot;wasmtime-runtime&amp;quot;
...

[dependencies]
wasmtime-environ &#x3D; { path &#x3D; &amp;quot;../environ&amp;quot;, version &#x3D; &amp;quot;0.30.0&amp;quot; }  ## Ported to &#x60;no_std&#x60; previously
libc &#x3D; { version &#x3D; &amp;quot;0.2.82&amp;quot;, default-features &#x3D; false }         ## Ported to Theseus in prior post
region &#x3D; &amp;quot;2.1.0&amp;quot;         ## Ported to Theseus in prior post
log &#x3D; &amp;quot;0.4.8&amp;quot;            ## Supports &#x60;no_std&#x60;
memoffset &#x3D; &amp;quot;0.6.0&amp;quot;      ## Supports &#x60;no_std&#x60;
indexmap &#x3D; &amp;quot;1.0.2&amp;quot;       ## Supports &#x60;no_std&#x60;
thiserror &#x3D; &amp;quot;1.0.4&amp;quot;      ## Use &#x60;thiserror_core2&#x60; instead
more-asserts &#x3D; &amp;quot;0.2.1&amp;quot;   ## Ported to &#x60;no_std&#x60; in prior post
cfg-if &#x3D; &amp;quot;1.0&amp;quot;           ## Supports &#x60;no_std&#x60;
backtrace &#x3D; &amp;quot;0.3.61&amp;quot;     ## Ported to Theseus in this post
lazy_static &#x3D; &amp;quot;1.3.0&amp;quot;    ## Supports &#x60;no_std&#x60;
rand &#x3D; &amp;quot;0.8.3&amp;quot;           ## Offers &#x60;no_std&#x60;-compatible &#x60;SmallRng&#x60;
anyhow &#x3D; &amp;quot;1.0.38&amp;quot;        ## Supports &#x60;no_std&#x60;, with code changes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Over the past several weeks, we have completed our modifications to &lt;code&gt;wasmtime-runtime&lt;/code&gt; such that it now builds properly on Theseus!
The key missing parts were:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Crate / Feature&lt;/th&gt;
&lt;th&gt;Summary&lt;/th&gt;
&lt;th&gt;Reason Needed for &lt;code&gt;wasmtime-runtime&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Cross-platform crate for capturing stack traces&lt;/td&gt;
&lt;td&gt;For capturing and analyzing stack traces to see if any WASM module functions exist on the call stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::path&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Module for manipulating and parsing file paths&lt;/td&gt;
&lt;td&gt;To refer to WASM module files, and for (de)serialization&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;resume_unwind()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Continues a panic action (e.g., unwinding), but skips the registered panic hook&lt;/td&gt;
&lt;td&gt;To continue propagating a panic across a native code-WASM boundary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;thiserror&lt;/code&gt;/&lt;code&gt;anyhow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Helper crates for convenient error handling&lt;/td&gt;
&lt;td&gt;To derive the &lt;code&gt;Error&lt;/code&gt; trait and easily return error types&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Signal handling&lt;/td&gt;
&lt;td&gt;Registering signal handlers, e.g., for &lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGILL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;For catching OS-level exceptions that occur while executing native code compiled from WASM modules&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#backtrace-to-the-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;backtrace-to-the-future&quot;&gt;&lt;/a&gt;&lt;code&gt;Back&lt;/code&gt;(&lt;code&gt;trace&lt;/code&gt;) to the Future&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;wasmtime-runtime&lt;/code&gt; crate uses &lt;code&gt;backtrace&lt;/code&gt; to capture a stack trace when a &lt;em&gt;trap&lt;/em&gt; occurs, such as a fault during WASM execution or another systems-level problem like Out Of Memory (OOM).
This trace is used to both:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Traverse the call stack to see if any stack frames from WASM code exist, and&lt;/li&gt;
&lt;li&gt;Provide the user or caller of Wasmtime with more context about a runtime failure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Porting &lt;code&gt;backtrace&lt;/code&gt; was relatively simple; the primary changes required were to publicly expose more details about Theseus&#x27;s custom unwinder.
Feel free to &lt;a href&#x3D;&quot;https://github.com/theseus-os/backtrace-rs/compare/5e15d73..c56bae0&quot;&gt;check out the full changeset here&lt;/a&gt;, summarized below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Theseus&#x27;s unwinder calculates the register values for each stack frame. We simply use those values to provide &lt;code&gt;backtrace&lt;/code&gt; with:
&lt;ul&gt;
&lt;li&gt;The stack frame&#x27;s instruction pointer (i.e., &lt;em&gt;call site address&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;The current stack pointer at that execution point&lt;/li&gt;
&lt;li&gt;The starting address of its containing function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Theseus supports &lt;em&gt;symbolication&lt;/em&gt;: resolving an address into a symbol
&lt;ul&gt;
&lt;li&gt;This uses Theseus&#x27;s crate management metadata, a &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/mod_mgmt/struct.CrateNamespace.html&quot;&gt;&lt;code&gt;CrateNamespace&lt;/code&gt;&lt;/a&gt;, which contains a map of all public symbols in that namespace&lt;/li&gt;
&lt;li&gt;The key function is &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/mod_mgmt/struct.CrateNamespace.html#method.get_section_containing_address&quot;&gt;&lt;code&gt;get_section_containing_address()&lt;/code&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;This is similar to the &lt;a href&#x3D;&quot;https://linux.die.net/man/1/addr2line&quot;&gt;&lt;code&gt;addr2line&lt;/code&gt;&lt;/a&gt; tool, but it works with Theseus&#x27;s dynamically loading and linked code structure&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The one remaining feature that our port of &lt;code&gt;backtrace&lt;/code&gt; lacks is connecting a resolved symbol to its location: file path, line number, and column number.
This is conceptually easy to do but requires debug information to be parsed from an object file.
Although &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/debug_info/index.html&quot;&gt;Theseus does support parsing DWARF debug info&lt;/a&gt;, it isn&#x27;t always available because debug info is typically stripped from object files to keep their size down.
Fortunately, the &lt;code&gt;backtrace&lt;/code&gt; crate treats this information as optional, and thus Wasmtime doesn&#x27;t require it to be available, so we can simply return &lt;code&gt;None&lt;/code&gt; when asked for symbol location details.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#the-path-forwards&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-path-forwards&quot;&gt;&lt;/a&gt;The &lt;code&gt;Path&lt;/code&gt; Forwards&lt;/h4&gt;
&lt;p&gt;Many Wasmtime crates use &lt;code&gt;std::path::{Path, PathBuf}&lt;/code&gt; to refer to WASM module files that are JIT-compiled and loaded into a Wasmtime engine.
Thus, we must implement a version of path types that are API-compatible with Rust&#x27;s &lt;code&gt;std::path&lt;/code&gt; types in order to minimize the number of changes to Wasmtime itself.
You can find &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/6a4ba4f42ae407afe71dd77042fa15a523e15134&quot;&gt;the code for that here&lt;/a&gt;, which is primarily a quick &amp;amp; dirty copy of the code from &lt;code&gt;std::path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Theseus already offers &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/path/struct.Path.html&quot;&gt;its own &lt;code&gt;Path&lt;/code&gt; type&lt;/a&gt;, which is similar but not identical to those in Rust &lt;code&gt;std::path&lt;/code&gt;.
All we need is a simple glue code layer between &lt;code&gt;std::PathBuf&lt;/code&gt; and Theseus&#x27;s &lt;code&gt;path::Path&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One notable difference between &lt;code&gt;std::path&lt;/code&gt; and &lt;code&gt;theseus_path&lt;/code&gt; is that Theseus uses Rust &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; types natively, so there is no need for the equivalent types &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt;; these types become simple typedefs in Theseus:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub type OsString &#x3D; String;
pub type OsStr &#x3D; str;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#relax-and-unwind&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;relax-and-unwind&quot;&gt;&lt;/a&gt;Relax and unwind&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;resume_unwind()&lt;/code&gt; function is used in Wasmtime to carry on with the unwinding procedure after it has been &lt;em&gt;caught&lt;/em&gt;. This is currently only used in the runtime&#x27;s trap handling logic, which essentially continues unwinding after a trap that stemmed from a Rust-level panic, i.e., one deemed irrelevant to handling in-WASM traps.&lt;/p&gt;
&lt;p&gt;Here is Theseus&#x27;s &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/ca960df2a61d807f23514469a94355ee2689c556#diff-d17ff1523da38049c7e75df2747fc33e3a18dea8c6a57ecb1ba5590ff6f1a699&quot;&gt;implementation of &lt;code&gt;resume_unwind()&lt;/code&gt; with code that tests it&lt;/a&gt;.
Although this is conceptually tricky, the implementation is quite straightforward ‚Äî simply start unwinding from the current point without starting from the regular panic handler.
You can test this in Theseus by invoking the test program &lt;code&gt;unwind_test -c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To actually use our new &lt;code&gt;resume_unwind()&lt;/code&gt; function in &lt;code&gt;wasmtime-runtime&lt;/code&gt;, we add &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/blob/076a39724c76ad29423db5e4aae7ef1d15530693/crates/runtime/src/traphandlers.rs#L267-L272&quot;&gt;the following very simple code block&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[cfg(feature &#x3D; &amp;quot;std&amp;quot;)]
std::panic::resume_unwind(panic);
#[cfg(target_os &#x3D; &amp;quot;theseus&amp;quot;)]
theseus_catch_unwind::resume_unwind(
    KillReason::Panic(PanicInfoOwned::from_payload(panic))
);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The notable difference between Theseus&#x27;s &lt;code&gt;resume_unwind&lt;/code&gt; and Rust&#x27;s &lt;code&gt;std::panic::resume_unwind&lt;/code&gt; is that we allow unwinding to occur from both a language-level panic and &lt;em&gt;beneath&lt;/em&gt; the language level after a CPU-level &amp;quot;machine&amp;quot; exception.
Thus, Theseus&#x27;s panic payloads expect a &lt;a href&#x3D;&quot;&quot;&gt;&lt;code&gt;KillReason&lt;/code&gt;&lt;/a&gt; rather than an erased type &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt;, so we must handle that minor difference.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#oh-an-error-occurred-anyway-anyhow&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;oh-an-error-occurred-anyway-anyhow&quot;&gt;&lt;/a&gt;Oh, an &lt;code&gt;Error&lt;/code&gt; Occurred? &lt;s&gt;Anyway&lt;/s&gt; Anyhow...&lt;/h4&gt;
&lt;p&gt;In yet another tribute to D. Tolnay, Wasmtime uses his superb &lt;code&gt;anyhow&lt;/code&gt; and &lt;code&gt;thiserror&lt;/code&gt; crates for convenient error handling across nearly every source file and function.
While &lt;code&gt;anyhow&lt;/code&gt; technically supports &lt;code&gt;no_std&lt;/code&gt; environments like Theseus, it cannot accommodate the same API.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thus, we must change &lt;strong&gt;&lt;em&gt;every&lt;/em&gt;. &lt;em&gt;single&lt;/em&gt;. &lt;em&gt;usage&lt;/em&gt;.&lt;/strong&gt; of &lt;code&gt;anyhow&lt;/code&gt; in the whole Wasmtime code base.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The majority of the changes simply require use to add this snippet to any &lt;code&gt;Result&lt;/code&gt; type before returning or unwrapping it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;.map_err(anyhow::Error::msg)?  // convert the &#x60;Err&#x60; into &#x60;anyhow::Error&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;because in &lt;code&gt;no_std&lt;/code&gt; environments, &lt;code&gt;anyhow::Error&lt;/code&gt; does not &lt;code&gt;impl std::error::Error&lt;/code&gt; and thus cannot perform the implicit conversion; we must do it explicitly.
This rough edge is currently unavoidable, as evidenced by &lt;a href&#x3D;&quot;https://github.com/dtolnay/anyhow#no-std-support&quot;&gt;&lt;code&gt;anyhow&lt;/code&gt;&#x27;s documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As you can see, most of these changes are functionally unnecessary. The real reason for such tedium is that the &lt;code&gt;Error&lt;/code&gt; trait is defined in Rust&#x27;s &lt;code&gt;std&lt;/code&gt; library and is thus unavailable for use in &lt;code&gt;no_std&lt;/code&gt; environments that only use &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;alloc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thankfully, supporting &lt;code&gt;thiserror&lt;/code&gt; is a bit easier, thanks to the &lt;a href&#x3D;&quot;https://github.com/bbqsrc/thiserror-core2&quot;&gt;&lt;code&gt;thiserror_core2&lt;/code&gt; crate&lt;/a&gt; that ports it to emit a derivation of the &lt;a href&#x3D;&quot;https://github.com/technocreatives/core2&quot;&gt;&lt;code&gt;core2::error::Error&lt;/code&gt; trait&lt;/a&gt;. We can simply use this as a drop-in replacement for &lt;code&gt;thiserror&lt;/code&gt; because we already use &lt;code&gt;core2::error::Error&lt;/code&gt; as a substitute for &lt;code&gt;std::error::Error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;üí§üí≠üí§ We dream of the day when &lt;a href&#x3D;&quot;https://github.com/yaahc&quot;&gt;@Jane Lusby&lt;/a&gt;&#x27;s excellent work on moving the &lt;code&gt;Error&lt;/code&gt; trait into &lt;code&gt;core&lt;/code&gt; is completed! Once that lands, we won&#x27;t need to bother with all this pablum.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#the-last-jedi-dependency-signal-handling&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-last-jedi-dependency-signal-handling&quot;&gt;&lt;/a&gt;The Last &lt;s&gt;Jedi&lt;/s&gt; Dependency: Signal Handling&lt;/h4&gt;
&lt;p&gt;The last remaining feature needed to finish porting &lt;code&gt;wasmtime-runtime&lt;/code&gt; is signal handling.
This is needed for Wasmtime to be able to catch traps that occur when executing WASM code that was JIT-compiled into native code, among other purposes.&lt;/p&gt;
&lt;p&gt;Theseus doesn&#x27;t offer POSIX-like signals because they&#x27;re unsafe and unnecessary in a safe-language OS, but it does implement handlers for &lt;a href&#x3D;&quot;https://wiki.osdev.org/Exceptions&quot;&gt;CPU exceptions&lt;/a&gt;, e.g., page faults, general protection faults, etc.
However, we previously did not allow third-party crates to register handlers (callbacks)&lt;/p&gt;
&lt;p&gt;Registering  &amp;quot;signal&amp;quot; (CPU exception) handlers is now supported in Theseus as of &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/09ccbfc644da93e98ef11c9532ef926f1ee7b4f4&quot;&gt;commit &lt;/a&gt;.
The initial implementation is limited to the following four categories of &amp;quot;signals&amp;quot;, which was loosely based on the set of signals that &lt;code&gt;wasmtime-runtime&lt;/code&gt; cares about.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// The possible &amp;quot;signals&amp;quot; that may occur due to CPU exceptions.
pub enum Exception {
    /// (SIGSEGV) Bad virtual address, unexpected page fault.
    InvalidAddress     &#x3D; 0,
    /// (SIGILL) Invalid opcode, malformed instruction, etc.
    IllegalInstruction &#x3D; 1,
    /// (SIGBUS) Bad memory alignment, non-existent physical address.
    BusError           &#x3D; 2,
    /// (SIGFPE) Bad arithmetic operation, e.g., divide by zero.
    ArithmeticError    &#x3D; 3,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each task can register one handler function for each category of exceptions:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub trait ExceptionHandler &#x3D; FnOnce(&amp;amp;ExceptionContext) -&amp;gt; Result&amp;lt;(), ()&amp;gt;;

pub fn register_handler(
    exception: Exception,
    handler: Box&amp;lt;dyn ExceptionHandler&amp;gt;,
) -&amp;gt; Result&amp;lt;(), ()&amp;gt; {
    HANDLERS.with(|handlers| {
        let handler_slot &#x3D; &amp;amp;handlers[exception as usize];
        if handler_slot.borrow().is_some() {
            return Err(());
        }
        *handler_slot.borrow_mut() &#x3D; Some(handler);
        Ok(())
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the Thread-Local Storage (TLS) areas are used to efficiently access the handlers registered for each given task:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;thread_local!{
    /// The &amp;quot;signal&amp;quot; handlers registered for each task.
    static HANDLERS: [RefCell&amp;lt;Option&amp;lt;Box&amp;lt;dyn ExceptionHandler&amp;gt;&amp;gt;&amp;gt;; 4] &#x3D; Default::default();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When an exception occurs, the CPU jumps synchronously to the kernel function specified in the interrupt descriptor table (IDT).
We simply &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/13406ed975d54b5d72afb313df370d0a4477ce01/kernel/exceptions_full/src/lib.rs#L185-L200&quot;&gt;add a condition to each IDT exception function&lt;/a&gt; to check for and obtain the relevant registered exception handler (if one exists).
The registered handler is then invoked with the following contextual information about said exception; the key information is the &lt;code&gt;instruction_pointer&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// Information that is passed to a registered [&#x60;ExceptionHandler&#x60;]
/// about an exception that occurred during execution.
pub struct ExceptionContext {
    pub instruction_pointer: VirtualAddress,
    pub stack_pointer: VirtualAddress,
    pub exception: Exception,
    pub error_code: Option&amp;lt;ErrorCode&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature is &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/blob/e333d4441ad3bf634476e5b34e79fc3ff98f4fdb/crates/runtime/src/traphandlers/theseus.rs#L40-L48&quot;&gt;used in the trap handling component&lt;/a&gt; of our port of &lt;code&gt;wasmtime-runtime&lt;/code&gt;, which needs the above context to determine whether the exception occurred in a section of code that came from a compiled WASM module.
Of course, the handlers must first be registered as part of the &lt;a href&#x3D;&quot;https://github.com/theseus-os/wasmtime/blob/e333d4441ad3bf634476e5b34e79fc3ff98f4fdb/crates/runtime/src/traphandlers/theseus.rs#L16-L26&quot;&gt;platform-specific init procedure shown here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#onwards-and-upwards&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;onwards-and-upwards&quot;&gt;&lt;/a&gt;Onwards and Upwards&lt;/h2&gt;
&lt;p&gt;With that, our port of &lt;code&gt;wasmtime-runtime&lt;/code&gt; is complete!
We&#x27;re nearly done with the &amp;quot;minimum viable port&amp;quot; of wasmtime functionality, as the only remaining crates are &lt;code&gt;wasmtime-jit&lt;/code&gt; and the top-level &lt;code&gt;wasmtime&lt;/code&gt; crate itself.
Once those are complete, we will publish a longer-form post about the journey to get wasmtime running on Theseus.&lt;/p&gt;
&lt;p&gt;Be on the lookout for such good news soon!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#miscellaneous-contributions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;miscellaneous-contributions&quot;&gt;&lt;/a&gt;Miscellaneous Contributions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fixed an &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/78d0e008f9b5b89a11fca388442f395cde040569&quot;&gt;issue with TLS sections&lt;/a&gt;, which required adding support for loading &lt;code&gt;.tbss&lt;/code&gt; (TLS BSS) sections&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jacob-earle&quot;&gt;@Jacob Earle&lt;/a&gt; implemented a &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/23bcfce0eb4303cb21ea3ff38afba8ae04013eab&quot;&gt;rate-monotonic scheduler&lt;/a&gt; for pseudo-real-time task scheduling
&lt;ul&gt;
&lt;li&gt;Adds a &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/sleep/index.html&quot;&gt;&lt;code&gt;sleep&lt;/code&gt; crate&lt;/a&gt; that handles blocking a task for a given number of system ticks&lt;/li&gt;
&lt;li&gt;Supports the notion of &amp;quot;periodic&amp;quot; tasks that run a short workload, go to sleep, and then wake back up at the beginning of every period&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/be9e9ed2c4a4baef45e321b2aa1fe50ea399218d&quot;&gt;Updated to the latest Rust 1.61 nightly version&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;This was required to fix the ABI issues in LLVM, wherein the &lt;code&gt;&amp;quot;x86-interrupt&amp;quot;&lt;/code&gt; ABI for exception handlers didn&#x27;t properly match what the CPU pushes onto the stack before jumping to said handler&lt;/li&gt;
&lt;li&gt;Needed as part of &lt;a href&#x3D;&quot;#the-last-sjedis-dependency-signal-handling&quot;&gt;the aforementioned effort&lt;/a&gt; to support registering third-party &amp;quot;signal&amp;quot; (exception) handlers in Theseus&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kevin contributed a &lt;a href&#x3D;&quot;https://github.com/rust-osdev/x86_64/pull/354&quot;&gt;tiny PR&lt;/a&gt; back to the &lt;code&gt;x86_64&lt;/code&gt; crate
&lt;ul&gt;
&lt;li&gt;We had been using our own outdated fork for a while, but we now use the &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/7d979328b3a6c2b59a29aa0b43d96f5997b36171&quot;&gt;latest version of the &lt;code&gt;x86_64&lt;/code&gt; crate&lt;/a&gt; with a tiny addition to support a &lt;code&gt;LockedIDT&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/Ramla-I&quot;&gt;@Ramla Ijaz&lt;/a&gt; finished implementing &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/700daa0f959243c04e424c64649ca5660b5cb210&quot;&gt;packet tranmission for the Mellanox 100GiB NIC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>Progress porting wasmtime-runtime to Theseus</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/02/03/wasmtime-progress-update.html" type="text/html" title="Progress porting wasmtime-runtime to Theseus" />
        <published>2022-02-03T00:00:00+00:00</published>
        <updated>2022-02-03T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/02/03/wasmtime-progress-update.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/02/03/wasmtime-progress-update.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#porting-wasmtime-runtime-the-key-wasmtime-crate&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;porting-wasmtime-runtime-the-key-wasmtime-crate&quot;&gt;&lt;/a&gt;Porting &lt;code&gt;wasmtime-runtime&lt;/code&gt;, the key Wasmtime crate&lt;/h2&gt;
&lt;p&gt;A &lt;a href&#x3D;&quot;../../../2021/12/31/November-December-Update-WASM.html&quot;&gt;previous post from late 2021&lt;/a&gt; chronicled our ongoing journey to port Wasmtime to Theseus.
While our bottom-up approach got off to a strong start, we quickly encountered our first major challenge when examining the &lt;code&gt;wasmtime-runtime&lt;/code&gt; crate, as it contains many dependencies on platform-specific and legacy system interfaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unix-like memory mapping and protection&lt;/li&gt;
&lt;li&gt;Signal/trap handling&lt;/li&gt;
&lt;li&gt;Thread-local storage&lt;/li&gt;
&lt;li&gt;Stack introspection and backtracing&lt;/li&gt;
&lt;li&gt;File and I/O abstractions&lt;/li&gt;
&lt;li&gt;Exception (panic) handling and unwinding resumption&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post describes our progress over a few weeks of working to add these features to Theseus in order to support &lt;code&gt;wasmtime-runtime&lt;/code&gt;&#x27;s many complex dependencies.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#porting--reorganizing-third-party-libraries&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;porting--reorganizing-third-party-libraries&quot;&gt;&lt;/a&gt;Porting &amp;amp; reorganizing third-party libraries&lt;/h3&gt;
&lt;p&gt;We first re-organized Theseus&#x27;s repository to include two folders for third-party crates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libs/&lt;/code&gt;: contains standalone crates that don&#x27;t depend on Theseus, but can be used by Theseus and others.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ports/&lt;/code&gt;: contains crates that have been ported to depend directly on Theseus-specific crates, e.g., those in &lt;code&gt;kernel/&lt;/code&gt; and are thus not standalone.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The main features ported over the past couple of months (early winter 2021-2022) are shown in the table below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Crate / Feature&lt;/th&gt;
&lt;th&gt;Summary&lt;/th&gt;
&lt;th&gt;Reason Needed for &lt;code&gt;wasmtime-runtime&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;libc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rust wrapper around the actual platform-specific &lt;code&gt;libc&lt;/code&gt; implementation&lt;/td&gt;
&lt;td&gt;Used to establish memory mappings and register signal handlers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;region&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Cross-platform APIs for virtual memory functions&lt;/td&gt;
&lt;td&gt;Used to allocate large chunks of memory and remap/protect memory regions as exec/read/write as needed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TLS&lt;/td&gt;
&lt;td&gt;Thread-Local Storage areas&lt;/td&gt;
&lt;td&gt;Used for &lt;code&gt;thread_local!()&lt;/code&gt; macro, which is needed to handle traps and stack unwinding upon exceptions that occur while executing native code that was JIT-compiled from a WASM binary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;object&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Helper crate for reading/writing object files, e.g., ELF&lt;/td&gt;
&lt;td&gt;Used to read object files generated by &lt;code&gt;cranelift&lt;/code&gt;&#x27;s backend and to manage unwind info&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#porting-libc-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;porting-libc-to-theseus&quot;&gt;&lt;/a&gt;Porting &lt;code&gt;libc&lt;/code&gt; to Theseus&lt;/h4&gt;
&lt;p&gt;Support for a minimal subset of &lt;code&gt;libc&lt;/code&gt; functionality has been an ongoing but low-priority effort, mostly for two reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Running C code directly on Theseus is inherently unsafe, as C is not a safe language and can thus violate Theseus&#x27;s language safety-based isolation and resource usage guarantees.&lt;/li&gt;
&lt;li&gt;No crates that Theseus depends on have needed an underlying &lt;code&gt;libc&lt;/code&gt;, thus Theseus as a platform did not need to offer one... until now.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Theseus&#x27;s libc implementation is called &lt;code&gt;tlibc&lt;/code&gt;. which is described in &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/book/c/programs.html&quot;&gt;this book chapter&lt;/a&gt;.
So far it has been loosely based on the Redox project&#x27;s &lt;code&gt;relibc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our efforts of late were focused on supporting &lt;code&gt;mmap&lt;/code&gt; for POSIX-style memory mappings, which Theseus has traditionally eschewed because they are unsafe and poorly-designed from a state management perspective&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.
In the future, we also may support POSIX-style signal handlers, but for now we have chosen to re-implement Wasmtime&#x27;s signal handling directly in safe Rust atop Theseus rather than going through an unsafe &lt;code&gt;libc&lt;/code&gt; FFI boundary for no good reason.&lt;/p&gt;
&lt;p&gt;The bulk of the &lt;code&gt;mmap&lt;/code&gt; implemenation for &lt;code&gt;tlibc&lt;/code&gt; was added in &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/fffda853e71b5a0d7b20b850297962227e592850&quot;&gt;commit fffda85&lt;/a&gt;.
The key aspects of this are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tlibc&lt;/code&gt; exposes a POSIX-style &lt;code&gt;mmap()&lt;/code&gt; function that calls Theseus APIs to instantiate new &lt;code&gt;MappedPages&lt;/code&gt; objects, and then saves them in a private list so that they aren&#x27;t dropped until the corresponding &lt;code&gt;munmap()&lt;/code&gt; call is invoked.
&lt;ul&gt;
&lt;li&gt;This is required because Theseus&#x27;s abstraction of a virtual memory mapping, &lt;code&gt;MappedPages&lt;/code&gt;, is auto-unmapped upon &lt;code&gt;drop&lt;/code&gt; to guarantee safety.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Currently, &lt;code&gt;mlock&lt;/code&gt; and &lt;code&gt;munlock&lt;/code&gt; are dummy functions because Theseus doesn&#x27;t perform any swapping or paging to disk.&lt;/li&gt;
&lt;li&gt;Memory protection (&lt;code&gt;mprotect&lt;/code&gt;) is offered, but is currently limited because Theseus forces all current memory mappings to be marked as &amp;quot;present&amp;quot; in the page table.
&lt;ul&gt;
&lt;li&gt;Thus, stripping read permissions from a mapping technically works, but it violates the guarantees of the &lt;code&gt;MappedPages&lt;/code&gt; type, i.e., the mapping is present and valid for the entire lifetime of a &lt;code&gt;MappedPages&lt;/code&gt; object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While we were at it, we went even further with additional improvements to &lt;code&gt;theseus_cargo&lt;/code&gt;, &lt;code&gt;libc&lt;/code&gt;, and &lt;code&gt;tlibc&lt;/code&gt; to &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/870fb246af68d02be7981374687b80c1429f48eb&quot;&gt;facilitate integration of Rust and C code&lt;/a&gt; atop Theseus.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each time we implement a new feature in &lt;code&gt;tlibc&lt;/code&gt;, we must also update
&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/d0fbcd0e11d56183bb306d43430dc65d4d640869&quot;&gt;Here&#x27;s an example of that for &lt;code&gt;mmap&lt;/code&gt;&lt;/a&gt;, with some testing functions included.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;theseus_cargo&lt;/code&gt; now supports building out-of-tree components &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/a685e062848d3b1522b2b962c21f51facb25726e&quot;&gt;that depend on both Rust and C code&lt;/a&gt;, e.g., native libraries.
&lt;ul&gt;
&lt;li&gt;It also now supports building &lt;code&gt;rlib&lt;/code&gt; and &lt;code&gt;staticlib&lt;/code&gt; crate types.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We added &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/4b83e95cf128a0ecd67a6c5de39f18f8bb317048&quot;&gt;basic &lt;code&gt;stdio&lt;/code&gt; features to &lt;code&gt;tlibc&lt;/code&gt;&lt;/a&gt;, e.g., for &lt;code&gt;printf&lt;/code&gt;, which is useful for testing purposes.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In summary, we fixed all the issues with &lt;code&gt;tlibc&lt;/code&gt;, &lt;code&gt;libc&lt;/code&gt;, and &lt;code&gt;theseus_cargo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, Rust and C code (both in-tree and out-of-tree components) can all be compiled and loaded/linked together in Theseus.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#porting-region-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;porting-region-to-theseus&quot;&gt;&lt;/a&gt;Porting &lt;code&gt;region&lt;/code&gt; to Theseus&lt;/h4&gt;
&lt;p&gt;With &lt;code&gt;tlibc&lt;/code&gt; now supporting basic &lt;code&gt;libc&lt;/code&gt; memory mapping functions, porting the &lt;code&gt;region&lt;/code&gt; crate was fairly straightforward.&lt;/p&gt;
&lt;p&gt;However, importantly, we chose to &lt;em&gt;not&lt;/em&gt; force &lt;code&gt;region&lt;/code&gt; on Theseus to depend on &lt;code&gt;tlibc&lt;/code&gt;, mainly because it would introduce another layer of unsafety.
The &lt;a href&#x3D;&quot;https://github.com/theseus-os/region-rs/commit/b4de9a22b5c3c8a1e2b9f2834fe33df27472891e#diff-761c91258f20f42f7145ee39c2cbac444849c5a5285f5d9695a3aeea4d27c6d5&quot;&gt;primary implementation of &lt;code&gt;alloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; are here&lt;/a&gt;, which are similar to the &lt;code&gt;mmap()&lt;/code&gt; implemenation in &lt;code&gt;tlibc&lt;/code&gt;.
We also must express the &lt;a href&#x3D;&quot;https://docs.rs/region/3.0.0/region/struct.Protection.html&quot;&gt;&lt;code&gt;region::Protection&lt;/code&gt;&lt;/a&gt; type in terms of Theseus&#x27;s page table &lt;code&gt;EntryFlags&lt;/code&gt;, which was generally straightforward.&lt;/p&gt;
&lt;p&gt;The one tricky part of &lt;code&gt;region&lt;/code&gt; that we disliked is &lt;a href&#x3D;&quot;https://docs.rs/region/3.0.0/region/struct.QueryIter.html&quot;&gt;&lt;code&gt;QueryIter&lt;/code&gt;&lt;/a&gt;, which allows the caller to query &lt;em&gt;all&lt;/em&gt; virtual memory areas across the entire current virtual address space to find ones that span or overlap with a certain range of addresses.&lt;br /&gt;
This is problematic for a few reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Theseus&#x27;s state management philosophy dictates that it does not maintain a centralized list of all memory mappings, so there&#x27;s nothing to iterate over by default.&lt;/li&gt;
&lt;li&gt;Theseus provides a very safe and clear API for interacting with memory mappings, which &lt;a href&#x3D;&quot;https://docs.rs/region/3.0.0/region/fn.query_range.html&quot;&gt;&lt;code&gt;region::query_range()&lt;/code&gt;&lt;/a&gt; completely ignores because it assumes a POSIX-style virtual memory API.&lt;/li&gt;
&lt;li&gt;Theseus strives to prevent &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use&quot;&gt;TOCTTOU attacks&lt;/a&gt; by avoiding the concept of a &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Handle_(computing)&quot;&gt;handles that point to a resource indirectly&lt;/a&gt;. By design (and by necessity atop conventional OSes), &lt;code&gt;QueryIter&lt;/code&gt; separates the &amp;quot;time of check&amp;quot; from the &amp;quot;time of use&amp;quot;, leading to potentially confusing behavior and errors in which a memory region returned from a query no longer exists by the time one attempts to use it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the end, our solution was to allow &lt;code&gt;QueryIter&lt;/code&gt; to expose and return &lt;strong&gt;only references to the memory areas already created by the &lt;code&gt;region&lt;/code&gt; crate itself&lt;/strong&gt;. This strives to mitigate safety issues that could arise by exposing &lt;em&gt;all&lt;/em&gt; memory regions maintained by Theseus to higher-level Rust code that may use them unsafely through the &lt;code&gt;region&lt;/code&gt; APIs.
Hopefully this feature restriction doesn&#x27;t pose a problem in the future.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#supporting-thread-local-storage-on-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;supporting-thread-local-storage-on-theseus&quot;&gt;&lt;/a&gt;Supporting Thread-Local Storage on Theseus&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread-Local Storage (TLS)&lt;/a&gt; allows one to declare a variable that will be instantiated on a per-thread basis, with each thread having its own local copy that other threads cannot access.
This is useful for many reasons, e.g., programming conveniencce, performant access to thread-specific data without locking, etc.
Our motivation for finally supporting it in its ultimate flexible form -- the ELF standard TLS areas -- stemmed from &lt;code&gt;wasmtime-runtime&lt;/code&gt;, which uses it in myriad ways.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: previously, Theseus offered a cheap imitation of TLS using the GS register to store limited, targeted data about each task, but it wasn&#x27;t usable by any applications, libraries, or even other non-&lt;code&gt;task&lt;/code&gt; kernel crates.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We implemented TLS support &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/3e6c50a0a45560057c6a35db4ce220760e362962&quot;&gt;across several commits&lt;/a&gt;.
This was a suprisingly complex and tricky implementation that required a lot of trial-and-error experimentation to determine how to correctly layout each TLS object in the per-task TLS area.&lt;/p&gt;
&lt;p&gt;Another complicating factor is that Theseus loads and links all crates at runtime, which means that our implementation &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/fd1f11d99f1b4252abb35fffe7ae45f9f7ca616b&quot;&gt;must support both statically-linked TLS areas from the base kernel image as well as newcomers found in dynamically-loaded crates&lt;/a&gt;.
There are a lot of tradeoffs herein as it relates to reserving and allocating offset ranges in the TLS space for TLS data sections, tracking TLS data sections per namespace, per crate, etc -- but these are best saved for a separate post about TLS.&lt;/p&gt;
&lt;p&gt;We went a step further by implementing &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/dd62aff423e1deceed503e3341827ba1e04dce79&quot;&gt;Rust&#x27;s &lt;code&gt;thread_local!()&lt;/code&gt; macro&lt;/a&gt; for any Theseus crate, which offers lazy dynamic initialization and cleanup of TLS areas.
This overcomes the limitations of standard ELF TLS sections, which behave like &lt;code&gt;static&lt;/code&gt; globals in Rust: they are &lt;code&gt;const&lt;/code&gt;-initialized and never dropped.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#porting-the-object-crate-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;porting-the-object-crate-to-theseus&quot;&gt;&lt;/a&gt;Porting the &lt;code&gt;object&lt;/code&gt; crate to Theseus&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;object&lt;/code&gt; crate is standalone and doesn&#x27;t need to be ported to Theseus specifically, thus we can simply port it to &lt;code&gt;no_std&lt;/code&gt; and place it in Theseus&#x27;s &lt;code&gt;libs/&lt;/code&gt; directory.
The only real difficulty here is that while &lt;code&gt;object&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; support &lt;code&gt;no_std&lt;/code&gt;,  no previous users of &lt;code&gt;object&lt;/code&gt; needed to &lt;em&gt;write&lt;/em&gt; to an object file in a &lt;code&gt;no_std&lt;/code&gt; environment.
Thinking about it, we do agree that&#x27;s kind of weird, but Theseus is just like that sometimes. üòä&lt;/p&gt;
&lt;p&gt;Once we convinced the maintainers of &lt;code&gt;object&lt;/code&gt; that this feature was necessary, the changes required to do so weren&#x27;t very involved.
It boiled down to a rearrangement of &lt;code&gt;object&lt;/code&gt;&#x27;s Cargo features and configuration blocks: check out the &lt;a href&#x3D;&quot;https://github.com/gimli-rs/object/pull/400&quot;&gt;PR we submitted (that was accepted)&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#miscellaneous-improvements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;miscellaneous-improvements&quot;&gt;&lt;/a&gt;Miscellaneous Improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/05f1213a562639be74aa7ceaeef301a23e86e97a&quot;&gt;improved the page allocator&lt;/a&gt; to allow it to lazily merge contiguous freed chunks of pages.
&lt;ul&gt;
&lt;li&gt;This happens lazily after an allocation request first fails; it is possible to also do it proactively in &lt;code&gt;AllocatedPages::drop()&lt;/code&gt;, but that makes deallocation more expensive.&lt;/li&gt;
&lt;li&gt;Needed for loading C object files or static libraries with entry points at a fixed address, e.g., the default entry point of &lt;code&gt;0x400000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Future work: support building and loading position-independent executables (PIE, and PIC). This is required to simultaneously load multiple C executables at the same fixed address, because Theseus only offers a single virtual address space.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;See our &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/book/misc/papers_presentations.html&quot;&gt;OSDI 2020 paper&lt;/a&gt; for an in-depth discussion of this. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>WASM has landed!</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/01/25/WASM-Has-Landed.html" type="text/html" title="WASM has landed!" />
        <published>2022-01-25T00:00:00+00:00</published>
        <updated>2022-01-25T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/01/25/WASM-Has-Landed.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/01/25/WASM-Has-Landed.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#running-wasm--wasi-modules-in-a-safe-os-kernel&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;running-wasm--wasi-modules-in-a-safe-os-kernel&quot;&gt;&lt;/a&gt;Running WASM + WASI modules in a safe OS kernel&lt;/h2&gt;
&lt;p&gt;üöÄüöÄ WASM has now landed in Theseus! üöÄüöÄ&lt;/p&gt;
&lt;p&gt;With &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/f4aa715f0fc706a0e3b0f3f21057338c0b295ffb&quot;&gt;PR #472&lt;/a&gt; being merged in, Theseus&#x27;s main branch allows you to execute WASM modules (as precompiled WASM binaries) that use both the core WASM specification and basic WASI extensions.&lt;/p&gt;
&lt;p&gt;See our &lt;a href&#x3D;&quot;../../../2021/12/31/November-December-Update-WASM.html&quot;&gt;previous blog post&lt;/a&gt; for more about this effort.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#how-to-use-and-run-wasm-on-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-to-use-and-run-wasm-on-theseus&quot;&gt;&lt;/a&gt;How to use and run WASM on Theseus&lt;/h3&gt;
&lt;p&gt;Theseus doesn&#x27;t yet support running an actual compiler, so you first need to download a pre-compiled WASM binary on the Theseus command line or package one up into the OS image itself during build time. We describe the latter approach below.&lt;/p&gt;
&lt;p&gt;Theseus&#x27;s build tooling now supports including arbitrary &amp;quot;extra files&amp;quot; in the generated OS &lt;code&gt;.iso&lt;/code&gt; image; &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/tree/theseus_main/extra_files&quot;&gt;click here to read more&lt;/a&gt; about that feature.
All you have to do is put whatever files you want included into the &lt;code&gt;extra_files/&lt;/code&gt; directory in the source code repository.
Presto-magic-change-o, these extra files will be automatically loaded into Theseus&#x27;s in-memory filesystem upon boot, in the &lt;code&gt;/extra_files&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Once you have a WASM binary, running it is easy with the &lt;code&gt;wasm&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-sh&quot;&gt;wasm /path/to/wasm/binary [args]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, try out the &lt;code&gt;exorbitant&lt;/code&gt; interactive calculator like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-sh&quot;&gt;wasm /extra_files/wasm/exorbitant.wasm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2022-posts/exorbitant-wasm.png&quot; alt&#x3D;&quot;exorbitant demo&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Our work on Wasmtime atop Theseus is still ongoing. Please check back for more updates soon!&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>2021: A Year in Review</title>
        <link rel="alternate" href="https://theseus-os.github.io/2022/01/13/Theseus-Year-In-Review-2021.html" type="text/html" title="2021: A Year in Review" />
        <published>2022-01-13T00:00:00+00:00</published>
        <updated>2022-01-13T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2022/01/13/Theseus-Year-In-Review-2021.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2022/01/13/Theseus-Year-In-Review-2021.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#theseuss-first-full-year&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;theseuss-first-full-year&quot;&gt;&lt;/a&gt;Theseus&#x27;s First Full Year&lt;/h2&gt;
&lt;p&gt;Although 2021 not the first year of Theseus development, it &lt;em&gt;was&lt;/em&gt; the first whole year in which:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Theseus was fully open-sourced and publically known to the community.&lt;/li&gt;
&lt;li&gt;Theseus received interest from academic and industry collaborators.&lt;/li&gt;
&lt;li&gt;Theseus received funding for open-source development from industry (yay!).&lt;/li&gt;
&lt;li&gt;Our focus shifted from prototyping research concepts to feature completeness, stabilization, and legacy compatibility.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Thanks to all the folks who contributed, advised, and interacted with myself and the rest of the Theseus team this year!&lt;/p&gt;
&lt;p&gt;We had an explosion of interest on GitHub:
&lt;img src&#x3D;&quot;/images/2022-posts/theseus-github-sshot.png&quot; alt&#x3D;&quot;theseus-github-screenshot&quot; /&gt;&lt;/p&gt;
&lt;p&gt;And official funding from Futurewei to continue Theseus development!
&lt;img src&#x3D;&quot;/images/2022-posts/theseus_plus_futurewei.svg&quot; alt&#x3D;&quot;Futurewei plus Theseus collab&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We look forward to another productive year!&lt;/p&gt;
&lt;p&gt;Time to get Theseus onto some real devices! &lt;sup&gt;hint hint&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#recap-major-new-developments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;recap-major-new-developments&quot;&gt;&lt;/a&gt;Recap: major new developments&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Ability to build out-of-tree crates against Theseus using &lt;code&gt;theseus_cargo&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;A novel extension of cargo to support building against prebuilt dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Basic WASM execution (using &lt;code&gt;wasmi&lt;/code&gt; interpreter) with core WASI support
&lt;ul&gt;
&lt;li&gt;Coming soon!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Continuing efforts to support headless, no-graphics operation&lt;/li&gt;
&lt;li&gt;General legacy compatibility improvements, including a fuller libc implementation&lt;/li&gt;
&lt;li&gt;Generic, dynamic, and arbitrary thread-local storage (TLS), plus a Rust-like &lt;code&gt;thread_local!()&lt;/code&gt; macro&lt;/li&gt;
&lt;li&gt;Tons of documentation, plus auto-published source docs and book docs!&lt;/li&gt;
&lt;li&gt;A full redesign of ergonomic and composable traits for device I/O, plus FAT FS support&lt;/li&gt;
&lt;li&gt;Performance and ergonomics improvements to the page and frame allocators&lt;/li&gt;
&lt;li&gt;Deferred interrupt handling tasks for better device driver performance and system interactivity&lt;/li&gt;
&lt;li&gt;and many more!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#thanks-to-2021s-contributors&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks-to-2021s-contributors&quot;&gt;&lt;/a&gt;Thanks to 2021&#x27;s Contributors!&lt;/h3&gt;
&lt;p&gt;Beyond our usual contributors, we had several newcomers from both Yale University and the open-source community at large who generously devoted their time to make some excellent improvements to Theseus.
Our sincere thanks to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Futurewei Technologies, especially &lt;a href&#x3D;&quot;https://www.linkedin.com/in/sid-askary-21a962&quot;&gt;Sid Askary&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.linkedin.com/in/yong-he-1334902&quot;&gt;Yong He&lt;/a&gt;, for generously offering technical advice and funding for Theseus development.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/apogeeoak&quot;&gt;@apogeeoak&lt;/a&gt;, who improved documentation quality and implemented GitHub workflows to autogenerate docs.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/vikrammullick&quot;&gt;Vikram Mullick&lt;/a&gt;, who began and nearly finished support for running WASM+WASI binaries atop Theseus.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jacob-earle&quot;&gt;Jacob Earle&lt;/a&gt;, who began support for logging output on ARM microcontrollers and a pseudo-real time scheduling algorithm for Theseus.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/joshtriplett&quot;&gt;Josh Triplett&lt;/a&gt;, who served as a valuable font of advice and sounding board for some of my wild Theseus ideas.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/phil-opp&quot;&gt;Philipp Oppermann&lt;/a&gt;, whose project &lt;a href&#x3D;&quot;https://os.phil-opp.com/&quot;&gt;Blog OS&lt;/a&gt; helped kickstart Theseus development a few years ago.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>November-December 2021 Update: We have WASM liftoff!</title>
        <link rel="alternate" href="https://theseus-os.github.io/2021/12/31/November-December-Update-WASM.html" type="text/html" title="November-December 2021 Update: We have WASM liftoff!" />
        <published>2021-12-31T00:00:00+00:00</published>
        <updated>2021-12-31T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2021/12/31/November-December-Update-WASM.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2021/12/31/November-December-Update-WASM.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#theseus-now-supports-wasm--wasi&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;theseus-now-supports-wasm--wasi&quot;&gt;&lt;/a&gt;Theseus now supports WASM + WASI&lt;/h2&gt;
&lt;p&gt;Great news -- executing WASM modules atop Theseus is now working!&lt;/p&gt;
&lt;p&gt;As proposed in a &lt;a href&#x3D;&quot;../../../2021/11/01/October-Update-WASM.html&quot;&gt;previous post&lt;/a&gt;, the initial implementation covers basic WASI system calls and uses the &lt;code&gt;wasmi&lt;/code&gt; crate to execute WASM binaries using an intepreter.&lt;/p&gt;
&lt;p&gt;Big thanks to &lt;a href&#x3D;&quot;https://github.com/vikrammullick&quot;&gt;Vikram Mullick&lt;/a&gt; for leading this effort. Our initial work was also inspired by early work from &lt;a href&#x3D;&quot;https://github.com/tomaka/redshirt&quot;&gt;redshirt&lt;/a&gt;, a WASM-based proof-of-concept system that also used &lt;code&gt;wasmi&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: this feature is not yet merged into the &lt;code&gt;theseus_main&lt;/code&gt; branch. It&#x27;s coming soon!
In the mean time, you can follow its progress in &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/472&quot;&gt;PR #472&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#demos-of-running-wasm-on-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;demos-of-running-wasm-on-theseus&quot;&gt;&lt;/a&gt;Demos of running WASM on Theseus&lt;/h3&gt;
&lt;p&gt;We have a few demo applications to show basic WASM + WASI functionality.&lt;/p&gt;
&lt;p&gt;First, a classic text adventure game called &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Zork#Zork_and_Dungeon&quot;&gt;Zork&lt;/a&gt;. This demonstrates using stdio through WASI-defined APIs.
&lt;img src&#x3D;&quot;/images/2021-posts/wzork.png&quot; alt&#x3D;&quot;zork&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Second, a simple version of &lt;code&gt;grep&lt;/code&gt; version 2.0 compiled to WASM, which demonstrates using WASI&#x27;s filesystem I/O interface.
&lt;img src&#x3D;&quot;/images/2021-posts/wgrep.png&quot; alt&#x3D;&quot;grep&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Once WASM support is officially in the main branch, we will offer an easier command line interface for loading and executing WASM binaries.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#progress-on-porting-wasmtime-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;progress-on-porting-wasmtime-to-theseus&quot;&gt;&lt;/a&gt;Progress on Porting Wasmtime to Theseus&lt;/h2&gt;
&lt;p&gt;While the interpreted WASM project is wrapping up, the port of Wasmtime is just getting started.&lt;/p&gt;
&lt;p&gt;As described in &lt;a href&#x3D;&quot;https://docs.wasmtime.dev/contributing-architecture.html&quot;&gt;Wasmtime&#x27;s documentation&lt;/a&gt;, the project is architected as one top-level user-facing crate that re-exports and connects together key functionality from several smaller internal crates.
The top-level crate is aptly named &lt;code&gt;wasmtime&lt;/code&gt;, and it primarily exposes a safe API for interacting with WASM modules, e.g., compiling, instantiating, and invoking them.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#bottom-up-approach----off-to-a-strong-start&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;bottom-up-approach----off-to-a-strong-start&quot;&gt;&lt;/a&gt;Bottom-up approach -- off to a strong start&lt;/h3&gt;
&lt;p&gt;We have taken a bottom-up approach such that we can iteratively port each crate to the Theseus environment, building and testing them as we go.
A diagram of the key crates that we care about and need to port is below.
&lt;img src&#x3D;&quot;/images/2021-posts/wasmtime-crate-structure.png&quot; alt&#x3D;&quot;diagram of wasmtime key crates&quot; /&gt;&lt;/p&gt;
&lt;p&gt;As such, the top-level &lt;code&gt;wasmtime&lt;/code&gt; crate will be the &lt;em&gt;last&lt;/em&gt; one that we port to Theseus.
So far, we have been able to quickly adapt the following bottom-most crates (shown in green above) to &lt;code&gt;no_std&lt;/code&gt; environments, as they are relatively standalone:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wasmparser&lt;/code&gt;: an external (non-wasmtime) tool for parsing WASM binaries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-types&lt;/code&gt;: definitions for core WASM types and execution concepts&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wasmtime-environ&lt;/code&gt;: support for abstract definitions of compiler environment and features, enabling easy use of the cranelift backend for JIT&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cranelift-entity&lt;/code&gt;: core data structures used by the Cranelift code generator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, we had to modify the following crates that were dependencies of wasmtime in order to support &lt;code&gt;no_std&lt;/code&gt; environments. We submitted PRs to each crate&#x27;s upstream repository, some of which have already been accepted. Thanks to those authors/maintainers!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;object&lt;/code&gt;: PR to &lt;a href&#x3D;&quot;https://github.com/gimli-rs/object/pull/400&quot;&gt;allow &lt;code&gt;no_std&lt;/code&gt; environments to &lt;em&gt;write&lt;/em&gt;, not just read, object files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;more_asserts&lt;/code&gt;: a trivial PR to &lt;a href&#x3D;&quot;https://github.com/thomcc/rust-more-asserts/pull/6&quot;&gt;add &lt;code&gt;no_std&lt;/code&gt; support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crc32fast&lt;/code&gt;: a tricky fix to &lt;a href&#x3D;&quot;https://github.com/srijs/rust-crc32fast/pull/22&quot;&gt;compilation for targets that lack some SIMD hardware features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexmap&lt;/code&gt;: PR to &lt;a href&#x3D;&quot;https://github.com/bluss/indexmap/pull/207&quot;&gt;unify the API between &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;no_std&lt;/code&gt; users&lt;/a&gt; of &lt;code&gt;indexmap&lt;/code&gt; data structures
&lt;ul&gt;
&lt;li&gt;Unfortunately, this one has been delayed due to &lt;code&gt;indexmap&lt;/code&gt;&#x27;s non-standard usage of features and auto-&lt;code&gt;std&lt;/code&gt; feature detection&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#looking-forward-in-wasmtime&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;looking-forward-in-wasmtime&quot;&gt;&lt;/a&gt;Looking forward in (wasm)time&lt;/h3&gt;
&lt;p&gt;The main challenge in porting Wasmtime to Theseus is porting the &lt;code&gt;wasmtime-runtime&lt;/code&gt; crate, which implements the majority of the runtime logic for executing WASM binaries atop a given host platform.
This crate is massive and will likely take months to complete, due to its many dependencies and robust usage of standard POSIX-like functionality that Theseus currently lacks.&lt;/p&gt;
&lt;p&gt;We&#x27;ll start by tackling the main dependencies of &lt;code&gt;wasmtime-runtime&lt;/code&gt;, most of which are based around legacy POSIX-style interfaces and traditional OS platform abstractions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unix-like memory mapping and protection&lt;/li&gt;
&lt;li&gt;Signal/trap handling&lt;/li&gt;
&lt;li&gt;Thread-local storage&lt;/li&gt;
&lt;li&gt;Stack introspection and backtracing&lt;/li&gt;
&lt;li&gt;File and I/O abstractions&lt;/li&gt;
&lt;li&gt;Exception (panic) handling and unwinding resumption&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Look for updates in the next post!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#miscellaneous-contributions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;miscellaneous-contributions&quot;&gt;&lt;/a&gt;Miscellaneous Contributions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Kevin wrote a &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/book/subsystems/task.html&quot;&gt;new book chapter&lt;/a&gt; about how Theseus&#x27;s task management subsystem works.&lt;/li&gt;
&lt;li&gt;Fixed a &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/issues/451&quot;&gt;rare bug&lt;/a&gt; in the &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/456&quot;&gt;frame allocator&lt;/a&gt;, originally identified by Ramla. Thanks to her for catching that!&lt;/li&gt;
&lt;li&gt;Fixed a classic off-by-one &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/issues/473&quot;&gt;bug&lt;/a&gt; that caused buffered &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/983532ac6dc6d7ccd69faf5c62f38e3b9760c4d6&quot;&gt;stdio reads to drop one character&lt;/a&gt; when the buffer was full. Thanks to Vikram for catching this!&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>October 2021 Update: All about WASM</title>
        <link rel="alternate" href="https://theseus-os.github.io/2021/11/01/October-Update-WASM.html" type="text/html" title="October 2021 Update: All about WASM" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2021/11/01/October-Update-WASM.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2021/11/01/October-Update-WASM.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#bringing-the-wonderful-world-of-wasm-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;bringing-the-wonderful-world-of-wasm-to-theseus&quot;&gt;&lt;/a&gt;Bringing the Wonderful World of WASM to Theseus&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Theseus&#x27;s newest goal is to be a &lt;strong&gt;WASM-native&lt;/strong&gt; system, in which a fully-featured WASM runtime can execute in a bare metal environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://webassembly.org/&quot;&gt;WebAssembly&lt;/a&gt; (WASM) is a powerful new binary instruction format that offers a &amp;quot;sandboxed&amp;quot; execution environment based on a simple machine model.
WASM&#x27;s goal is to allow code from a variety of programming languages to be easily deployed on and performantly executed within a web browser-provided environment, effectively realizing the portability dream once envisioned by Java&#x27;s bytecode format.&lt;/p&gt;
&lt;p&gt;In addition, multiple extensions to the standard help to expand WASM&#x27;s functionality beyond just what is offered by most browsers.
The most notable is &lt;a href&#x3D;&quot;https://github.com/WebAssembly/WASI&quot;&gt;WASI&lt;/a&gt;, the WebAssembly System Interface, which extends WASM&#x27;s core functionality with common system-provided features like standard I/O, filesystems, clocks and timekeeping, and more.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#why-wasm-on-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-wasm-on-theseus&quot;&gt;&lt;/a&gt;Why WASM on Theseus?&lt;/h3&gt;
&lt;p&gt;WASM is the solution to one of the major downsides of safe-language OSes: all components must be written in a safe language in order to uphold the isolation and safety guarantees provided by said language compiler.
This can make it tedious or impossible to support legacy components and interfaces.&lt;/p&gt;
&lt;p&gt;With a WASM runtime, Theseus could safely load and run software modules written in any arbitrary unsafe language!
All you&#x27;d need to do is compile them into a WASM module, which is quite easy thanks to most major languages supporting WASM targets.
This will also make it significantly easier to run legacy components with complex dependency chains atop Theseus, as we can bundle them all up into self-contained WASM modules with little to no external dependencies.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#how-do-we-get-there&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-do-we-get-there&quot;&gt;&lt;/a&gt;How do we get there?&lt;/h3&gt;
&lt;p&gt;To bring WASM to Theseus, we have started two concurrent projects:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The simple approach: use the &lt;a href&#x3D;&quot;https://github.com/paritytech/wasmi&quot;&gt;&lt;code&gt;wasmi&lt;/code&gt; intepreter crate from parity-tech&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Relatively simple, as &lt;code&gt;wasmi&lt;/code&gt; is &lt;code&gt;no_std&lt;/code&gt;-compliant and requires only minimal interfacing with the host platform in order to use it&lt;/li&gt;
&lt;li&gt;We can implement WASI system calls as needed, which acts as the glue is the glue between the WASM environment and the rest of Theseus&#x27;s subsystems&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The complex approach: port the &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime&quot;&gt;Wasmtime WASM runtime project&lt;/a&gt; to Theseus
&lt;ul&gt;
&lt;li&gt;Massively complex with dozens of platform-specific logic and API calls&lt;/li&gt;
&lt;li&gt;Tons of legacy dependencies, e.g., libc- and POSIX-style memory management, signal handling, system calls, and usage of many Rust libstd features&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/vikrammullick&quot;&gt;Vikram Mullick&lt;/a&gt; has begun working on part 1 above as part of his senior capstone project at Yale.
&lt;a href&#x3D;&quot;https://github.com/kevinaboos&quot;&gt;Kevin Boos&lt;/a&gt; has begun working on part 2 above, and will also assist with part 1 as needed.&lt;/p&gt;
&lt;p&gt;Due to the complex nature of Wasmtime with its many legacy dependencies, this two-pronged split approach is quite beneficial, giving us the best of both worlds:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Theseus can &amp;quot;quickly&amp;quot; get up and running with basic WASM support, allowing us to:
&lt;ul&gt;
&lt;li&gt;Experiment with running legacy components as WASM modules&lt;/li&gt;
&lt;li&gt;Begin implementing support for WASI and other key WASM interfaces, e.g., WebGL&lt;/li&gt;
&lt;li&gt;Integrate Theseus&#x27;s existing runtime loading and linking infrastructure with WASM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can leverage the existing WASM and WASI infrastructure layers to more easily support Wasmtime
&lt;ul&gt;
&lt;li&gt;This will realize a ~10x performance improvement over the initial &lt;code&gt;wasmi&lt;/code&gt;, without wasting the initial &lt;code&gt;wasmi&lt;/code&gt;-based efforts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We look forward to announcing WASM support for Theseus and realizing its full potential as a WASM-native system.&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>August/September Update: A Proper Terminal Emulator</title>
        <link rel="alternate" href="https://theseus-os.github.io/2021/10/04/August-September-Update.html" type="text/html" title="August/September Update: A Proper Terminal Emulator" />
        <published>2021-10-04T00:00:00+00:00</published>
        <updated>2021-10-04T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2021/10/04/August-September-Update.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2021/10/04/August-September-Update.html">&lt;p&gt;As mentioned in our &lt;a href&#x3D;&quot;../../../2021/08/02/June-July-2021-Update.html&quot;&gt;previous update&lt;/a&gt;, we&#x27;re working to support headless operation in Theseus such that it can run in an seL4 guest VM, which doesn&#x27;t support graphical displays.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#going-headless-with-a-proper-terminal-interface&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;going-headless-with-a-proper-terminal-interface&quot;&gt;&lt;/a&gt;Going Headless with a Proper Terminal Interface&lt;/h2&gt;
&lt;p&gt;We took a three-step approach towards realizing a proper headless interactive terminal:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Removing the requirement that a graphical display (e.g., VGA device) must exist for Theseus to successfully boot.
&lt;ul&gt;
&lt;li&gt;Now, if no display devices are not found, bootstrap and init can proceed, and headless operation is assumed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Devising a new input dataflow and event manager, with the serial port as the focal data source and sink.
&lt;ul&gt;
&lt;li&gt;Monitors input sources for new connections asynchronously and spawns handlers for them upon receival.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create a new terminal emulator that:
&lt;ul&gt;
&lt;li&gt;Offers abstraction layers to support both graphical &lt;em&gt;and&lt;/em&gt; non-graphical terminals.&lt;/li&gt;
&lt;li&gt;Supports conventional escape and control codes, compliant with most ANSI, VT100, and xterm.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#yet-another-serial-port-driver-redesign&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;yet-another-serial-port-driver-redesign&quot;&gt;&lt;/a&gt;Yet Another Serial Port Driver Redesign&lt;/h3&gt;
&lt;p&gt;Our existing serial port driver was very simple -- it synchronously transmitted output bytes and simply dumped input bytes.
Thus, the receive interrupt handler was trivially simple and executed quickly.&lt;/p&gt;
&lt;p&gt;However, the added complexity of doing actual work (e.g., spawning a new console/terminal instance) in the receive interrupt handler caused it to become prohibitively expensive to run.
Executing long-running operations in an interrupt handler is unacceptable: &lt;em&gt;(i)&lt;/em&gt; it prevents that CPU from doing any other work, and &lt;em&gt;(ii)&lt;/em&gt; it harms system interactiveness by preventing other interrupts from being handled.&lt;/p&gt;
&lt;p&gt;To avoid this, we used Theseus&#x27;s &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/async_channel/index.html&quot;&gt;asynchronous channels&lt;/a&gt; to establish a communication channel between the serial port interrupt handler and a separate &lt;em&gt;listener&lt;/em&gt; task.
The listener task blocks until receiving a notification from any serial port, upon which it spawns a new console and terminal instance using that serial port and an input source and an output sink.&lt;/p&gt;
&lt;p&gt;This design has one drawback: it requires &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/3e805f1799964f5b63c48d7ad6a072f130256445/kernel/console/src/lib.rs#L32-L39&quot;&gt;proactively spawning a dedicated task just to listen for notifications from the serial port&lt;/a&gt;.
That led us to realize that it was time to introduce a better abstraction: deferred and/or linked interrupt handlers.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#deferred-interrupt-handlers&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;deferred-interrupt-handlers&quot;&gt;&lt;/a&gt;Deferred Interrupt Handlers&lt;/h4&gt;
&lt;p&gt;Theseus&#x27;s &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/deferred_interrupt_tasks/index.html&quot;&gt;Deferred Interrupt Handlers&lt;/a&gt; are an extension of the concept of &amp;quot;bottom half&amp;quot; and &amp;quot;top half&amp;quot; interrupt handlers&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Interrupt Handler&lt;/em&gt; (aka &amp;quot;top half&amp;quot;): the short, latency-sensitive function that runs synchronously, immediately when the interrupt request is serviced. It typically does two things:
&lt;ol&gt;
&lt;li&gt;Notifies the deferred task that work is ready to be done (optionally providing details about that work), and&lt;/li&gt;
&lt;li&gt;Acknowledges the interrupt such that the hardware knows it was handled.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Deferred task&lt;/em&gt; (aka &amp;quot;bottom half&amp;quot;): the more complex function that runs in a deferred manner to handle longer operations.
&lt;ul&gt;
&lt;li&gt;Runs asynchronously in a non-interrupt context and can thus perform more long-running operations without blocking the rest of that CPU&#x27;s workloads.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Theseus&#x27;s deferred interrupt handling implementation is conceptually similar to but differs from tasklets and workqueues in Linux.
The deferred task is uniquely tied to an interrupt handler in a 1-to-1 manner upon creation and are fully type-safe; there is a direct, strongly-typed channel of communication between them&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.
The deferred task can also optionally be configured to execute immediately after the interrupt handler in order to reduce I/O device latency, thanks to scheduler integration.&lt;/p&gt;
&lt;p&gt;Our favorite side benefit of this design is that itencourages adherence to the &lt;em&gt;separation of concerns&lt;/em&gt; principle, as the interrupt handling functionality must be conciously divided into an &amp;quot;urgent&amp;quot; synchronous part and a deferred asynchronous part.&lt;/p&gt;
&lt;p&gt;With this new interrupt handling architecture, we were able to adapt the serial driver to work efficiently without having unnecessary listener tasks wasting memory and CPU cycles.
The serial port is a simple case, as the interrupt handler only need to notify the deferred task that data has been received on the port and then acknowledge the interrupt; no other data exchange is needed.
The deferred task can then read all received data from the serial port in a non-urgent manner and do anything else necessary, such as spawning new console/terminal instances.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#splitting-the-serial-port-driver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;splitting-the-serial-port-driver&quot;&gt;&lt;/a&gt;Splitting the Serial Port Driver&lt;/h4&gt;
&lt;p&gt;Theseus&#x27;s design specifies a &lt;em&gt;tiny&lt;/em&gt; minimal kernel boot image, the &lt;code&gt;nano_core&lt;/code&gt; which must include only the bare minimum components to be able to bootstrap the OS and then dynamically load all other OS initialization components.
One of these components is the serial port driver, as it&#x27;s the only real usable choice for early boot/kernel logging in the absence of display, networking, or file support.&lt;/p&gt;
&lt;p&gt;With the above additions to the serial port driver, namely the usage of deferred interrupts and channels, the driver was becoming far too complex.
It had gone from having zero dependencies to having dozens.
That bloated the size of the &lt;code&gt;nano_core&lt;/code&gt;, thereby harming the dynamicness of Theseus.&lt;/p&gt;
&lt;p&gt;To solve this, we &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/d6b86b6c46004513735079bed47ae21fc5d4b29d&quot;&gt;split the serial port driver into two parts&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/serial_port_basic/index.html&quot;&gt;Basic driver&lt;/a&gt;: a standalone crate that exposes the &lt;code&gt;SerialPort&lt;/code&gt; type, which only offers functions to initialize, read from, and write to the device.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/serial_port/index.html&quot;&gt;Full driver&lt;/a&gt;: offers full I/O support with trait implementations, deferred interrupts, channel usage, task blocking, and more.
&lt;ul&gt;
&lt;li&gt;Wraps the basic driver&#x27;s &lt;code&gt;SerialPort&lt;/code&gt; type with additional functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This design enables two previously-conflicting goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The majority of system components can access the full functionality of the serial port and use it just like any other I/O device.&lt;/li&gt;
&lt;li&gt;The kernel boot image is kept tiny with minimal dependencies whilst still being able to output logs to the serial port.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#a-complete-terminal-emulator-rewrite&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-complete-terminal-emulator-rewrite&quot;&gt;&lt;/a&gt;A Complete Terminal Emulator Rewrite&lt;/h3&gt;
&lt;p&gt;Finally, we began the most complicated component of true interactive headless operation: a terminal emulator.
Theseus&#x27;s existing terminal is fairly ad-hoc and doesn&#x27;t conform to any real standards; it was implemented quickly as a summer intern project and offers just enough features to run commands and display their output.
The same is true for Theseus&#x27;s &lt;code&gt;stdio&lt;/code&gt;, which is a &amp;quot;quick-n-dirty&amp;quot; inflexible implementation that uses heap buffers instead of a real file abstraction.&lt;/p&gt;
&lt;p&gt;As anyone who has dealt with this knows, terminal emulators are &lt;em&gt;exceedingly&lt;/em&gt; and unexpectedly complex.
We experimented with multiple iterations of the design, primarily centered around how best to represent each displayable &amp;quot;unit&amp;quot; or &amp;quot;cell&amp;quot; on the terminal display:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, in which each element can contain either a single character or a string of characters (no matter how wide) as long as they have the same style.
&lt;ul&gt;
&lt;li&gt;Easy to output to a text backend.&lt;/li&gt;
&lt;li&gt;The most memory efficient.&lt;/li&gt;
&lt;li&gt;Calculating line wrapping and cursor navigation is overly complex because each unit may have a different columnar display width.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, but each element in the line can only contain a single &lt;em&gt;character&lt;/em&gt;.
&lt;ul&gt;
&lt;li&gt;Slightly less memory efficient, as it duplicates units that have the same style.&lt;/li&gt;
&lt;li&gt;Easier to calculate displayed rows and cursor movement than design 1, but still complex.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a dynamic number of elements per line, but each element corresponds to a &lt;em&gt;single displayed column&lt;/em&gt; on screen.
&lt;ul&gt;
&lt;li&gt;Requires more memory and a little bit of extra effort to support wide characters, since they must be split across more than one element.&lt;/li&gt;
&lt;li&gt;Much, much easier to calculate cursor movements, line wrapping, and display commands.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The terminal grid stores a fixed number of elements per line, equivalent to the width of the screen row; blank units are inserted to fill each linas necessary.
&lt;ul&gt;
&lt;li&gt;Very wasteful of memory, especially for short lines (common in terminal output).&lt;/li&gt;
&lt;li&gt;Trivial to calculate displayed rows and cursor movement.&lt;/li&gt;
&lt;li&gt;Very hard to re-size/re-flow the terminal.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After multiple iterations, we settled on &lt;strong&gt;Design 3&lt;/strong&gt; above.
It selects the best set of tradeoffs in the spectrum of design points, and most importantly, simplifies the translation between on-screen coordinates and scrollback buffer coordinate.&lt;/p&gt;
&lt;p&gt;One interesting aspect of Theseus&#x27;s terminal emulator is how it&#x27;s split into multiple components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;frontend&lt;/em&gt;: a single entity responsible for handling incoming character and control/escape code bytes and determining what actions should be taken.
&lt;ul&gt;
&lt;li&gt;The frontend is also reusable as a terminal driver, &lt;code&gt;readline&lt;/code&gt; library, and line discipline layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;backend&lt;/em&gt; abstraction: a trait that represents the various display actions that a terminal might invoke.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;backend&lt;/em&gt; implentation(s): one of multiple entity types that handles display actions to &amp;quot;render&amp;quot; the terminal output in different formats:
&lt;ul&gt;
&lt;li&gt;Graphical pixel framebuffers&lt;/li&gt;
&lt;li&gt;Classic 80x25 VGA screen with 16-color basic text display&lt;/li&gt;
&lt;li&gt;A serial port connected to a host-side pseudo-terminal&lt;/li&gt;
&lt;li&gt;A network connection or file or any other sink&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, this is still a work in progress and is not yet used for Theseus&#x27;s main terminal display.
It takes quite a lot of effort to get all the details right, but we have an MVP that supports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Insert/replace mode switching&lt;/li&gt;
&lt;li&gt;Automatic CR/LF behavior with wrapping&lt;/li&gt;
&lt;li&gt;Multiple different PTY backends, e.g., &lt;code&gt;screen&lt;/code&gt;, &lt;code&gt;picocom&lt;/code&gt;, &lt;code&gt;minicom&lt;/code&gt;, etc&lt;/li&gt;
&lt;li&gt;Most ANSI escape/control codes, including colors and text styles&lt;/li&gt;
&lt;li&gt;Cursor movement and scrolling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, there are several Rust terminal emulators that serve as valuable examples, e.g., &lt;a href&#x3D;&quot;https://github.com/alacritty&quot;&gt;Alacritty&lt;/a&gt;, but they&#x27;re standalone monolithic projects that rely on an underlying graphics stack like OpenGL and are thus inappropriate for in-kernel usage.
We were able to use the excellent &lt;a href&#x3D;&quot;https://crates.io/crates/vte&quot;&gt;&lt;code&gt;vte&lt;/code&gt;&lt;/a&gt; crate from the Alacritty project though, which saved a lot of time and effort in parsing ANSI/VT100 control codes.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Did you know that the &amp;quot;grid&amp;quot; of a terminal screen is indexed starting at &lt;code&gt;(1,1)&lt;/code&gt; rather than &lt;code&gt;(0,0)&lt;/code&gt; for the upper-leftmost character? &lt;sup&gt; Oh, how I wish I knew that earlier...&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#other-improvements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-improvements&quot;&gt;&lt;/a&gt;Other Improvements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Improved safety, complexity, and performance of &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/419&quot;&gt;interpreting a memory region as an executable function&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Previously called &lt;code&gt;MappedPages::as_func()&lt;/code&gt;, now moved into the crate management subsystem as a member function of the &lt;code&gt;LoadedSection&lt;/code&gt; type.&lt;/li&gt;
&lt;li&gt;The new &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/crate_metadata/struct.LoadedSection.html#method.as_func&quot;&gt;&lt;code&gt;LoadedSection::as_func()&lt;/code&gt; method&lt;/a&gt; already knows both the size of the function&#x27;s section and whether the underlying memory is executable, which omits multiple runtime checks.&lt;/li&gt;
&lt;li&gt;The function interface is much simpler, as the caller need not specify any size or offset values w.r.t. the memory region.&lt;/li&gt;
&lt;li&gt;Improves safety: offers a compile-time guarantee that an executable function instance can only be obtained from a &lt;code&gt;LoadedSection&lt;/code&gt; (with proper alignment and size) rather than any chunk of executable memory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Re-designed parts of the &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/df721e35221d361f8ec8fd87364133f0be0f5cde&quot;&gt;&lt;code&gt;Task&lt;/code&gt; struct to reduce lock contention&lt;/a&gt;, eliminating it in most places.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;Mutable&amp;quot; fields (those that may change after &lt;code&gt;Task&lt;/code&gt; creation) are now moved into a &lt;code&gt;TaskInner&lt;/code&gt; struct (excluding atomic fields), which allows most fields to be accessed without acquiring the lock on that &lt;code&gt;Task&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Immutable fields are kept in the &amp;quot;outer&amp;quot; &lt;code&gt;Task&lt;/code&gt; struct.&lt;/li&gt;
&lt;li&gt;We ensure atomic types are properly aligned and sized such that native atomic instructions are actually used. We realized this by switching from &lt;code&gt;atomic::Atomic&lt;/code&gt; to &lt;code&gt;crossbeam_utils::atomic::AtomicCell&lt;/code&gt;, plus static assertions that all types wrapped in &lt;code&gt;AtomicCell&lt;/code&gt; are actually eligible for native atomic access.&lt;/li&gt;
&lt;li&gt;Move a Task&#x27;s &lt;code&gt;ExitValue&lt;/code&gt; out of its &lt;code&gt;RunState&lt;/code&gt; enum so that the &lt;code&gt;RunState&lt;/code&gt; enum can be accessed atomically and independently of an &lt;code&gt;ExitValue&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;runstate&lt;/code&gt; and &lt;code&gt;running_on_cpu&lt;/code&gt; fields of &lt;code&gt;Task&lt;/code&gt; are now atomically accessible in a lock-free manner, allowing us to block/unblock tasks in lock-free contexts, e.g., within an interrupt handler.&lt;/li&gt;
&lt;li&gt;As more &lt;code&gt;Task&lt;/code&gt; fields are now readable without locking, we can remove all now-unnecessary unsafe statements from the &lt;code&gt;scheduler&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Other terminology is often used, including &amp;quot;first-level&amp;quot; and &amp;quot;second-level&amp;quot; interrupt handlers, or &amp;quot;hard&amp;quot; and &amp;quot;soft&amp;quot; interrupt handlers. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;It is also possible to have a pool of deferred tasks, in which each task can be tied to multiple interrupt handlers. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
    <entry>
        <title>June/July Update: Headless Operation on seL4</title>
        <link rel="alternate" href="https://theseus-os.github.io/2021/08/02/June-July-2021-Update.html" type="text/html" title="June/July Update: Headless Operation on seL4" />
        <published>2021-08-02T00:00:00+00:00</published>
        <updated>2021-08-02T00:00:00+00:00</updated>
        <id>https://theseus-os.github.io/2021/08/02/June-July-2021-Update.html</id>
        <content type="html" xml:base="https://theseus-os.github.io/2021/08/02/June-July-2021-Update.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#one-very-busy-very-hot-summer&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;one-very-busy-very-hot-summer&quot;&gt;&lt;/a&gt;One Very Busy, Very Hot Summer&lt;/h2&gt;
&lt;p&gt;In June of this year, the Seattle area hit record high temperatures of over 110¬∞F (44¬∞C) for three days. Ouch!&lt;/p&gt;
&lt;p&gt;We began this hot summer with the goal of enabling Theseus to run atop seL4, using both its hypervisor and VMM functionality to present Theseus with a standard &amp;quot;bare metal&amp;quot; x86 environment.
Unfortunately, we quickly discovered that while &lt;a href&#x3D;&quot;https://docs.sel4.systems/Tutorials/camkes-vm-linux.html&quot;&gt;seL4 supports ARM and x86&lt;/a&gt;, it does not yet fully support x86_64 VMMs, which is the only architecture that Theseus currently runs on.
The implementation of an x86_64 VMM was supposedly &lt;a href&#x3D;&quot;https://dornerworks.com/blog/64-bit-x86-architecture-on-sel4/&quot;&gt;completed by Dornerworks&lt;/a&gt;, but we were unable to get it to successfully run any x86_64 guest OS (but x86 VMs did work properly).
We have decided to postpone this particular effort until &lt;a href&#x3D;&quot;https://github.com/seL4/seL4/pull/324&quot;&gt;this PR&lt;/a&gt; that officially adds support for x86_64 VMMs on seL4 is accepted.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#headless-operation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;headless-operation&quot;&gt;&lt;/a&gt;Headless operation&lt;/h2&gt;
&lt;p&gt;In the meantime, we started working towards Theseus-level support for &lt;em&gt;headless&lt;/em&gt; operation over a serial port interface.
The serial port is the only form of direct interactive access to guest VMs on seL4 (excluding network access), so it is a necessary component to debug and use Theseus therein.
It&#x27;s also useful for communicating with serial devices on other more limited platforms, e.g., our &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/361&quot;&gt;WIP port of Theseus to ARM Cortex-M4 microcontrollers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Previously, Theseus had two problems in this area:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All input to the shell/terminal was assumed to come from a real keyboard and mouse.&lt;/li&gt;
&lt;li&gt;The serial port was only used for basic logging output (not treated as a regular I/O device).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To achieve headless operation, we had to set two corresponding goals:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Abstract the terminal and input handling to work with any I/O source, not just a physical keyboard.&lt;/li&gt;
&lt;li&gt;Enable full, bidirectional, arbitrary I/O across serial ports.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-io-abstractions--stateless-vs-stateful&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-io-abstractions--stateless-vs-stateful&quot;&gt;&lt;/a&gt;New I/O Abstractions:  Stateless vs. Stateful&lt;/h3&gt;
&lt;p&gt;As the first step towards these goals, we created &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/blob/051e52782658a3e0f11c486d8656e71da1f7ba07/kernel/io/src/lib.rs&quot;&gt;several new I/O traits&lt;/a&gt; to represent different categories of I/O.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockReader.html&quot;&gt;&lt;code&gt;BlockReader&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockWriter.html&quot;&gt;&lt;code&gt;BlockWriter&lt;/code&gt;&lt;/a&gt; traits represent I/O streams which can be read from or written to at the granularity of a single block (as the smallest transferable chunk).&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.BlockIo.html&quot;&gt;&lt;code&gt;BlockIo&lt;/code&gt;&lt;/a&gt; is a &amp;quot;parent&amp;quot; trait that specifies the size in bytes of each block
in a block-based I/O stream.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.KnownLength.html&quot;&gt;&lt;code&gt;KnownLength&lt;/code&gt;&lt;/a&gt;: a separate trait that represents an I/O stream with a known length, such as a disk drive.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.ByteReader.html&quot;&gt;&lt;code&gt;ByteReader&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/trait.ByteWriter.html&quot;&gt;&lt;code&gt;ByteWriter&lt;/code&gt;&lt;/a&gt;: traits that represent I/O streams which can be read from or written to at the granularity of an individual byte.&lt;/li&gt;
&lt;li&gt;We also provide wrapper types that allow byte-wise access atop block-based I/O streams: &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteReaderWrapper.html&quot;&gt;&lt;code&gt;ByteReaderWrapper&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteWriterWrapper.html&quot;&gt;&lt;code&gt;ByteWriterWrapper&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ByteReaderWriterWrapper.html&quot;&gt;&lt;code&gt;ByteReaderWriterWrapper&lt;/code&gt;&lt;/a&gt;.
&lt;ul&gt;
&lt;li&gt;The &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/fn.blocks_from_bytes.html&quot;&gt;&lt;code&gt;blocks_from_bytes()&lt;/code&gt;&lt;/a&gt; function is useful for calculating the set of block-based I/O transfers that are needed to satisfy an arbitrary byte-wise transfer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notably, these traits all offer &lt;em&gt;&lt;strong&gt;stateless&lt;/strong&gt;&lt;/em&gt; access to byte streams only, an important behavioral characteristic that helps simplify state management in Theseus.
This means that they don&#x27;t keep track of an internal offset within the stream.&lt;/p&gt;
&lt;p&gt;For example, the &lt;code&gt;ByteReader&lt;/code&gt; trait exposes only one function that requires the caller to specify at which offset the stream read should start.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn read_at(&amp;amp;mut self, buffer: &amp;amp;mut [u8], offset: usize) -&amp;gt; Result&amp;lt;...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These traits and types also &lt;em&gt;stack&lt;/em&gt; on top of each other, e.g., you can use a &lt;code&gt;ByteReader&lt;/code&gt; to realize byte-wise access to an underlying block-based I/O device that implements &lt;code&gt;BlockReader&lt;/code&gt;.
We make this easier with trait &lt;em&gt;delegation&lt;/em&gt;, in which wrapper types &amp;quot;forward&amp;quot; the trait implementation through:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;References (&lt;code&gt;&amp;amp;dyn ByteReader&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Mutable References (&lt;code&gt;&amp;amp;mut dyn ByteReader&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Locks (&lt;code&gt;Mutex&amp;lt;ByteReader&amp;gt;&lt;/code&gt;) using the &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.LockableIo.html&quot;&gt;&lt;code&gt;LockableIo&lt;/code&gt;&lt;/a&gt; type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also offer &lt;em&gt;&lt;strong&gt;stateful&lt;/strong&gt;&lt;/em&gt; I/O types, which wrap stateless I/O streams (the above traits) to track the current offset into the I/O stream while reading or writing it.
This is similar to classic POSIX I/O interfaces, but are strongly-typed and allow for limited permissions: &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.ReaderWriter.html&quot;&gt;&lt;code&gt;ReaderWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.Reader.html&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://www.theseus-os.com/Theseus/doc/io/struct.Writer.html&quot;&gt;&lt;code&gt;Writer&lt;/code&gt;&lt;/a&gt; structs.&lt;/p&gt;
&lt;p&gt;Finally, all of the above types and traits implement the &lt;code&gt;no_std&lt;/code&gt; version of &lt;code&gt;std::io::Read&lt;/code&gt;/&lt;code&gt;Write&lt;/code&gt; traits, which can come from crates like &lt;a href&#x3D;&quot;https://crates.io/crates/core_io&quot;&gt;&lt;code&gt;core_io&lt;/code&gt;&lt;/a&gt; or &lt;a href&#x3D;&quot;https://crates.io/crates/bare-io&quot;&gt;&lt;code&gt;bare_io&lt;/code&gt;&lt;/a&gt;.
This widely expands their compatibility to work with pretty much any other I/O-related code in the Rust ecosystem.&lt;/p&gt;
&lt;p&gt;For example, we used these new I/O abstractions to integrate the &lt;a href&#x3D;&quot;https://github.com/rafalh/rust-fatfs&quot;&gt;&lt;code&gt;fatfs&lt;/code&gt; Rust crate&lt;/a&gt; with Theseus, which allows Theseus to read and write the contents of a FAT filesystem on disk.
More work is required to provide a more generic file abstraction that can represent arbitrary files across any filesystem type, as Theseus&#x27;s current representation of files is quite ad-hoc and limited to in-memory filesystems.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#redesigned-serial-port-driver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;redesigned-serial-port-driver&quot;&gt;&lt;/a&gt;Redesigned Serial Port Driver&lt;/h3&gt;
&lt;p&gt;With redesigned I/O traits, we can proceed to our second goal: improving the serial port driver.&lt;/p&gt;
&lt;p&gt;On x86 machines, there are up to 4 serial ports, but commonly only one or two are available: &lt;code&gt;COM1&lt;/code&gt; and &lt;code&gt;COM2&lt;/code&gt;.
The OS can interact with them using different I/O ports, e.g., writing bytes to &lt;code&gt;0x3F8&lt;/code&gt; and the subsequent 7 port addresses will allow you to communicate with the &lt;code&gt;COM1&lt;/code&gt; serial port.
Here are three great resources for learning more about serial port behavior and how to write a proper driver: &lt;a href&#x3D;&quot;https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming&quot;&gt;one&lt;/a&gt;, &lt;a href&#x3D;&quot;https://tldp.org/HOWTO/Modem-HOWTO-4.html&quot;&gt;two&lt;/a&gt;, &lt;a href&#x3D;&quot;https://wiki.osdev.org/Serial_Ports&quot;&gt;three&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The changes we needed to make are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implement and activate interrupt handlers for all serial ports, such that the hardware triggers an interrupt when input bytes are received on the port.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SerialPort&lt;/code&gt; instances are no longer exclusively owned by the logger, as they must be accessible from within the serial port interrupt handler and other kernel/application crates.&lt;/li&gt;
&lt;li&gt;Implement the necessary read and write I/O traits for the &lt;code&gt;SerialPort&lt;/code&gt; type, so we can use them in all I/O stream contexts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these changes in place, Theseus is now able to read from and write to serial ports freely, as if it were any other I/O stream like a file or disk.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#other-improvements-to-theseus&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-improvements-to-theseus&quot;&gt;&lt;/a&gt;Other Improvements to Theseus&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Updated Theseus&#x27;s Rust compiler to version 1.54, which entailed &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/b7d62ee0197347b651e2cf1387f83c9c4a598633&quot;&gt;many changes&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Refactoring all inline assembly to Rust&#x27;s new &lt;code&gt;asm!()&lt;/code&gt; syntax.&lt;/li&gt;
&lt;li&gt;Complying with the restrictions on naked functions: Rust ABI is no longer allowed, and only one assembly block is permitted per naked function.&lt;/li&gt;
&lt;li&gt;Use the new &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.compare_exchange_weak&quot;&gt;&lt;code&gt;compare_exchange_weak()&lt;/code&gt;&lt;/a&gt; family of functions, which is more efficient on some architectures (ARM) because it is allowed to spuriously fail.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Refactored code for memory-related types to unify their APIs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/417&quot;&gt;&lt;code&gt;VirtualAddress&lt;/code&gt; and &lt;code&gt;PhysicalAddress&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/6854306a8f2c16f3caf1332120856a0fff8de25f&quot;&gt;&lt;code&gt;Page&lt;/code&gt; and &lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/commit/b09ad9bc73683397a0b16b9b53f9214bdf87c04d&quot;&gt;&lt;code&gt;PageRange&lt;/code&gt; and &lt;code&gt;FrameRange&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Book documentation: thanks to &lt;a href&#x3D;&quot;https://github.com/apogeeoak&quot;&gt;@apogeeoak&lt;/a&gt;, the Theseus Book now has clearer structure, automatic spell check, and is built and published online via GitHub Actions CI workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mellanox 100GiB NIC: &lt;a href&#x3D;&quot;https://github.com/Ramla-I&quot;&gt;Ramla Ijaz&lt;/a&gt; added basic support for &lt;a href&#x3D;&quot;https://github.com/theseus-os/Theseus/pull/404&quot;&gt;initializing and configuring this high-performance NIC&lt;/a&gt;. Packet transmission is an ongoing work in progress.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Added support for parsing the ACPI &lt;code&gt;DMAR&lt;/code&gt; table, which specifies details about the system&#x27;s IOMMU.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is part of our quest to protect Theseus&#x27;s single address space execution environment from errant or malicious I/O devices that attempt to access arbitrary system memory without permission, the one final frontier in the &amp;quot;chain of safety&amp;quot; that cannot be checking by the compiler.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#contributions-to-other-open-source-projects&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributions-to-other-open-source-projects&quot;&gt;&lt;/a&gt;Contributions to other Open-Source Projects&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We added &lt;a href&#x3D;&quot;https://github.com/rafalh/rust-fatfs/pull/44&quot;&gt;compile-time configuration of logging flexibility&lt;/a&gt; to the &lt;code&gt;rust-fatfs&lt;/code&gt; crate.&lt;/li&gt;
&lt;li&gt;We ported the MPMC Queue crate to &lt;a href&#x3D;&quot;https://github.com/brayniac/mpmc/pull/8&quot;&gt;support &lt;code&gt;no_std&lt;/code&gt; environments&lt;/a&gt; on the latest version of Rust.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Now that we have flexible, generic I/O abstractions available in Theseus, the next step for achieving full headless operation is to enable a terminal/CLI to handle I/O to and from arbitrary sources, such as a serial port.&lt;/p&gt;
</content>

        <author>
            <name>Kevin Boos</name>
        </author>
    </entry>
    
</feed>
